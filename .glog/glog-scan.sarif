{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-b0718ade-5d93-47fc-8740-e85daaf74571",
              "help": {
                "text": "",
                "markdown": "### Detected Issue with C Function (strlen) Vulnerability\n\nThe `strlen` function in C and C++ is used to determine the length of a null-terminated string. However, if the input to `strlen` is not properly validated, it can lead to vulnerabilities such as buffer overflows, which can be exploited to execute arbitrary code or cause a denial of service. This vulnerability typically arises when `strlen` is used on untrusted input without ensuring that the input is a valid, null-terminated string.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is a properly null-terminated string before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` which allows specifying a maximum length to prevent reading beyond the buffer.\n3. **Bounds Checking**: Implement bounds checking to ensure that the buffer size is not exceeded.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring>\n\n// Original vulnerable code\n// size_t length = strlen(nbuf);\n\n// Fixed code using strnlen\nsize_t safe_strlen(const char* nbuf, size_t max_len) {\n    return strnlen(nbuf, max_len);\n}\n\nint main() {\n    const char* nbuf = \"example\";\n    size_t max_len = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(nbuf, max_len);\n    std::cout << \"Length of string: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-42086b2a-63bf-4d99-ac4c-4bac9c70099f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises when the `strcpy` function is used in C++ programming. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions that perform bounds checking.\n2. **Input Validation**: Always validate input data to ensure it does not exceed buffer sizes.\n3. **Buffer Size Management**: Ensure that destination buffers are adequately sized to handle the maximum expected input size.\n4. **Use Modern C++ Features**: Prefer using C++ standard library features such as `std::string` which manage memory automatically and reduce the risk of buffer overflows.\n\n### Source Code Fix Recommendation\n\nReplace the vulnerable `strcpy` usage with a safer alternative. Here is a fixed version of the code using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n#include <cstdio>  // Required for printf\n\nstruct Buffer {\n    char ufnm[256]; // Ensure this buffer is large enough for expected data\n};\n\nvoid safeFunction(Buffer* b, const char* buf) {\n    // Use strncpy to prevent buffer overflow\n    strncpy(b->ufnm, buf, sizeof(b->ufnm) - 1);\n    b->ufnm[sizeof(b->ufnm) - 1] = '\\0'; // Ensure null-termination\n}\n\nint main() {\n    Buffer b;\n    const char* buf = \"Example string that is safe to copy.\";\n    safeFunction(&b, buf);\n    printf(\"Buffer content: %s\\n\", b.ufnm);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For `strncpy` function.\n- `<cstdio>`: For `printf` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-2ced5f1c-5172-45c3-a442-d20817ca2b06",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(buf)` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the null-terminating character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null byte, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar buf[100];\n// ... populate buf ...\nsize_t len = strlen(buf);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar buf[100];\n// ... populate buf ...\nsize_t max_len = sizeof(buf);\nsize_t len = strnlen(buf, max_len);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-8af54ca6-078c-4e5b-af76-6e86deee09f3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, particularly with an unsigned integer cast. This can lead to integer overflow, resulting in insufficient memory allocation, buffer overflows, or memory corruption. This vulnerability is critical as it can be exploited to execute arbitrary code, cause a program crash, or lead to data corruption.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input values before using them in memory allocation functions.\n2. **Use Safer Alternatives**: Consider using safer memory allocation functions like `calloc` or C++ alternatives like `new` which automatically handle type sizes.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Integer Overflow Checks**: Implement checks to prevent integer overflow when calculating the size of memory to allocate.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n\nint main() {\n    unsigned int num_elements = 100; // Example value\n    size_t size_to_allocate;\n\n    // Check for overflow before allocation\n    if (num_elements > std::numeric_limits<size_t>::max() / sizeof(int)) {\n        std::cerr << \"Integer overflow detected, cannot allocate memory safely.\" << std::endl;\n        return -1;\n    }\n\n    size_to_allocate = num_elements * sizeof(int);\n\n    int* array = (int*)malloc(size_to_allocate);\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return -1;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input/output operations.\n- `<limits>`: Required for checking the maximum size of data types.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-2ba8b737-0aae-4681-ab0d-dcb4cd56e5fc",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++ programming. This function is inherently unsafe because it does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program crash, or corrupt data.\n\nIn the provided code snippet, `strcpy(buf,\"tmp.FXXXXXX\")`, the function copies the string `\"tmp.FXXXXXX\"` into the buffer `buf` without checking if `buf` is large enough to hold the string. If `buf` is smaller than the length of the string, this will result in a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or `std::strncpy_s` (if available), which allow you to specify the size of the destination buffer.\n2. **Input Validation**: Always validate input sizes before copying data into buffers.\n3. **Buffer Size Management**: Ensure that buffers are adequately sized to hold the maximum expected data, including null terminators.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n\n### Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy` to prevent buffer overflow by specifying the maximum number of characters to copy, including space for the null terminator.\n\n```cpp\n#include <cstring> // Required for strncpy\n\nvoid safeCopy(char* buf, size_t bufSize) {\n    // Use strncpy to safely copy the string with buffer size limit\n    strncpy(buf, \"tmp.FXXXXXX\", bufSize - 1);\n    buf[bufSize - 1] = '\\0'; // Ensure null termination\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### Relevant Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-cbb4f143-a35c-4362-aab1-597e18908956",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when it is used on a potentially uninitialized or improperly validated pointer, such as `strlen(b->ufnm)`. This can lead to undefined behavior, including segmentation faults or buffer overflows, if the pointer does not point to a valid null-terminated string. This issue is often categorized under improper input validation or buffer handling vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all pointers are properly initialized and validated before use. Check that they point to valid, null-terminated strings.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that provide bounds checking, such as `std::string` in C++.\n3. **Null Checks**: Always perform null checks on pointers before using them in functions like `strlen`.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, you can modify the code to include proper checks and use safer alternatives:\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Assuming 'b' is a pointer to a struct with a member 'ufnm' of type char*\nstruct Buffer {\n    char* ufnm;\n};\n\nvoid processBuffer(Buffer* b) {\n    if (b == nullptr || b->ufnm == nullptr) {\n        std::cerr << \"Invalid buffer or uninitialized string.\" << std::endl;\n        return;\n    }\n\n    // Use std::string for safer string handling\n    std::string safeString(b->ufnm);\n    std::cout << \"String length: \" << safeString.length() << std::endl;\n}\n\nint main() {\n    Buffer buffer;\n    buffer.ufnm = \"example\";\n    processBuffer(&buffer);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard C++ library dependencies are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/): A list of the most critical web application security risks.\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/): A quick reference guide for secure coding practices.\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-187064f1-70ca-4409-a28f-0f13a110a0df",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(s)` function in C++ is used to find the length of a string. The vulnerability arises when the string `s` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen(s)` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your string after it has been modified.\n\n## Source Code Fix Recommendation\n\nInstead of using `strlen(s)`, consider using `strnlen(s, MAX_LEN)`, where `MAX_LEN` is the maximum expected length of your string. This function will only read up to `MAX_LEN` characters, preventing potential buffer overflows.\n\n```cpp\n#include <string.h>\n\n#define MAX_LEN 100\n\nchar s[MAX_LEN];\n// ... modify s ...\nsize_t len = strnlen(s, MAX_LEN);\n```\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the `<string.h>` library in C++.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-ef62f111-4183-476a-967b-638bf8d2daa0",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-9dd98a2d-0f1f-4de9-89ae-fe8ffcf8294d",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-55f27f92-a709-42ab-94d4-2875e7618116",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-1eef0c61-2d98-4a7c-aecb-bd24a75f18a0",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-d1ca20f0-b116-461c-b491-5799cb528b5f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or improper handling of null pointers. This vulnerability can be exploited to cause a program to crash or behave unpredictably, and in some cases, it can be leveraged to execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input sizes before using them in `malloc` to ensure they are within expected bounds.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using safer alternatives like `new` in C++ which automatically throws an exception on failure.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use Smart Pointers**: In C++, prefer using smart pointers (`std::unique_ptr`, `std::shared_ptr`) which automatically manage memory.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t len = 100; // Example length, should be validated\n    void* ptr = malloc(len);\n\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    free(ptr); // Ensure memory is freed\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-ad54d3ef-71d6-4239-b364-48ba2d6a9319",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-d808d4ff-c1c7-49c6-8a68-8ca30e1a6f07",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-af24422e-01f2-46e0-859c-e8e389ac8cda",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-75edd684-4800-44de-b89b-26c78a0ce45a",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-6cb67e92-3956-44ac-a0c9-22815d625e43",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-673ee2ee-57f8-45a8-bc28-54ee51dc1fc2",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-3aa3d908-ffa2-40ec-b4ae-96e3bb6671c6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question is related to the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the source or destination buffers are not properly sized, leading to potential buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy(\n  pack_a_buf + (ic * KC) + (kr_full_pieces_loop_limit * MR),\n  temp_pack_a_buf,\n  kr_partial_pieces * MR * sizeof(float)\n);\n```\n\nThe vulnerability occurs if the destination buffer (`pack_a_buf`) is not large enough to accommodate the data being copied from `temp_pack_a_buf`. This can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Buffer Size Validation**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by calculating the required size and comparing it against the actual size of the destination buffer.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Boundary Checks**: Implement boundary checks to ensure that the indices used in pointer arithmetic do not exceed the buffer limits.\n\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is adequately sized before performing the `memcpy` operation. Here's an example of how you might modify the code:\n\n```cpp\nsize_t required_size = (ic * KC) + (kr_full_pieces_loop_limit * MR) + (kr_partial_pieces * MR * sizeof(float));\nif (required_size <= destination_buffer_size) {\n    memcpy(\n      pack_a_buf + (ic * KC) + (kr_full_pieces_loop_limit * MR),\n      temp_pack_a_buf,\n      kr_partial_pieces * MR * sizeof(float)\n    );\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n```cpp\n#include <cstring>  // For memcpy\n#include <cstddef>  // For size_t\n```\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1518e37b-0602-4f77-b561-ac49fdc3254f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-5ba4551f-aa01-41a9-bc5f-3315d220d670",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-bbf03d4a-c79a-4465-ba5f-f9b4794e4f22",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings with a specified maximum length to prevent buffer overflows. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can lead to undefined behavior when the destination string is used, potentially causing security vulnerabilities such as buffer overflows or data corruption.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your code.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n#define POST_OPS_STR_LEN 5\n\nvoid safeCopy() {\n    char post_ops_str[POST_OPS_STR_LEN];\n    strncpy(post_ops_str, \"none\", POST_OPS_STR_LEN - 1);\n    post_ops_str[POST_OPS_STR_LEN - 1] = '\\0'; // Ensure null-termination\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: This header is required for using `strncpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-110cdf2a-d8ee-4a5a-85b3-d497a49a6af9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly, potentially leading to buffer overflows or data truncation. In C++, `strncpy` is often used to copy strings, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can lead to undefined behavior when the destination buffer is used as a string.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or C++ standard library functions such as `std::string` and its member functions.\n2. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null terminator.\n4. **Input Validation**: Validate input lengths before performing string operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative. If you must use `strncpy`, ensure proper null-termination:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Original code\n// strncpy(post_ops_str, ops_tok, POST_OPS_STR_LEN - 1);\n\n// Fixed code\nstd::strncpy(post_ops_str, ops_tok, POST_OPS_STR_LEN - 1);\npost_ops_str[POST_OPS_STR_LEN - 1] = '\\0'; // Ensure null-termination\n```\n\nAlternatively, use `std::string`:\n\n```cpp\n#include <string> // Required for std::string\n\nstd::string post_ops_str = ops_tok.substr(0, POST_OPS_STR_LEN - 1);\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<string>`: Required for `std::string`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-c21e67a6-fa35-466c-b94b-a33a4137f424",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used in a way that can lead to buffer overflows or other unintended behavior. In C++, `strncpy` is often used to copy strings, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can lead to vulnerabilities if the destination buffer is used without ensuring it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or C++ string classes (`std::string`) that manage memory automatically and ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Checks**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and prevent such vulnerabilities in the codebase.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative or ensure proper null-termination:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n#define GEMM_TYPE_STR_LEN 100\n\nvoid safeCopy(char* gemm_type_str, const char* ops_tok) {\n    // Use safer alternative or ensure null-termination\n    std::strncpy(gemm_type_str, ops_tok, GEMM_TYPE_STR_LEN - 1);\n    gemm_type_str[GEMM_TYPE_STR_LEN - 1] = '\\0'; // Ensure null-termination\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-e1cdee8a-509c-4dec-b328-6969f81f5ad7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows or memory corruption. This typically occurs when the size of the data being copied exceeds the size of the destination buffer, or when the source and destination buffers overlap. Such issues can lead to undefined behavior, crashes, or security vulnerabilities such as data leaks or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` if there is a possibility of overlapping buffers.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows.\n4. **Boundary Checks**: Implement boundary checks before performing memory operations.\n5. **Use C++ Standard Library**: Prefer using C++ standard library containers and algorithms which handle memory management automatically.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nmemcpy(c_ref, c, (size_C * sizeof(C_type)));\n```\n\n**Fix:**\n\n1. **Ensure Buffer Size**: Verify that `c_ref` has enough space to accommodate `(size_C * sizeof(C_type))` bytes.\n2. **Use `std::copy`**: If `c` and `c_ref` are arrays or pointers to elements of a type, consider using `std::copy` for safer copying.\n\n```cpp\n#include <algorithm> // for std::copy\n\n// Assuming c and c_ref are pointers to C_type and size_C is the number of elements\nstd::copy(c, c + size_C, c_ref);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<algorithm>`: This library is required for using `std::copy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9d53397f-00de-40b6-80d9-604197a9583c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used in a way that can lead to buffer overflows or improper null-termination of strings. In C++, `strncpy` is often used to copy strings with a specified maximum length, but it does not guarantee null-termination if the source string is longer than the specified length. This can lead to undefined behavior, including potential security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or C++ standard library functions such as `std::string` which handle memory management and null-termination automatically.\n2. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null-terminator.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability sink:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Original code\n// strncpy(post_ops_str_copy, post_ops_str, POST_OPS_STR_LEN-1);\n\n// Fixed code\nstrncpy(post_ops_str_copy, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_copy[POST_OPS_STR_LEN - 1] = '\\0'; // Ensure null-termination\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-d954b7a4-c952-4a01-82b9-4382ba5a2690",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-42edb526-f5cd-47dd-9f47-17970c798182",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-7173ae80-44d8-420a-82a3-188265dc8f03",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-c7b8d0ef-1e71-40de-a876-7eebec2640fa",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-3cc38cab-d736-47b5-a358-371676671f45",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-ac6b7bab-dcda-4991-a395-e1cec1233da0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-b36031d0-c2c7-424d-b5ea-8550863e5262",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-04f04a8c-ab32-4b1c-80ac-89e7993215be",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-b7adef19-d6c1-40d9-af40-0adc50c17696",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-f1f736fb-3c39-46a2-8843-892aae6bd6ed",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-6d3095fd-6d2f-4079-8173-ef2f4eee3197",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-1af2b1d8-d775-4c8f-8eea-80339a1d7b2d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-6b1d0304-0af5-47b7-bbf0-d1df4cec1053",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-1c3811e4-a1c2-49cb-9d64-f482c3f2e351",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-2816319a-c5af-41c5-998f-16644783802c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-0cd0ffdd-7dc2-43ec-807f-c0fa44c6bc43",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-d2c327dd-8f63-468a-9b42-c03535802fd6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-a112d9de-d41a-432e-b147-6d973c2ed6b8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-f5e88057-cfc4-4bfe-8729-76a048f72818",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-c67a6f5b-a3d3-4255-8c30-519e7ac1afc5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-b01d31bf-1161-458d-873d-c6b8b1bd9659",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-af6242a1-1d37-45b3-b33b-eefa83199eba",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-49f120a5-c148-4668-ac1b-8bb8a7e913e8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings with a specified maximum length to prevent buffer overflows. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can lead to undefined behavior when the destination string is used, potentially causing security vulnerabilities such as buffer overflows or data corruption.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your code.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n#define POST_OPS_STR_LEN 5\n\nvoid safeCopy() {\n    char post_ops_str[POST_OPS_STR_LEN];\n    strncpy(post_ops_str, \"none\", POST_OPS_STR_LEN - 1);\n    post_ops_str[POST_OPS_STR_LEN - 1] = '\\0'; // Ensure null-termination\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: This header is required for using `strncpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-70b21abf-75f9-494c-b4d3-535b26ad45df",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-d452ab80-3f17-4fc0-bfc0-3a998a6285a6",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-0c9c866a-4a15-4042-b139-b45651c30e53",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-1392d4e7-08b6-46ab-9b35-a3a5f69a876f",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-64427caa-5c86-4901-ba1c-a4e0bb45a29d",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-f4bb5cf8-7894-4e64-bde5-7c896f02b69f",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-0ba4424a-4544-4662-9d29-72aa5ec9248e",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-b0ff2396-540a-48f4-9159-871733471a17",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-70debcb7-95cc-41d4-ae96-f19ca1af837c",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-4774873a-e371-40cb-a4eb-3adb70c3a51b",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-70860644-3971-4ede-8389-02acbbe948d6",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-e95c82ef-24c3-41a7-9ed4-414631a06789",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-84af8758-cf9e-4a5c-82e7-105ca48d73cc",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-301d8861-0b11-4792-b127-cd695fe4e4ec",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-ceb7fc15-048c-4e6d-8822-a49e449088ac",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-9135bd81-ae92-49d3-ac44-70e41d2ecffa",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-f95aa7f3-26c1-408d-8546-debc4a6a7c97",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly, potentially leading to buffer overflows or data truncation. In C++, `strncpy` is often used to copy strings, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can lead to undefined behavior when the destination buffer is used as a string.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or C++ standard library functions such as `std::string` and its member functions.\n2. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null terminator.\n4. **Input Validation**: Validate input lengths before performing string operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative. If you must use `strncpy`, ensure proper null-termination:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Original code\n// strncpy(post_ops_str, ops_tok, POST_OPS_STR_LEN - 1);\n\n// Fixed code\nstd::strncpy(post_ops_str, ops_tok, POST_OPS_STR_LEN - 1);\npost_ops_str[POST_OPS_STR_LEN - 1] = '\\0'; // Ensure null-termination\n```\n\nAlternatively, use `std::string`:\n\n```cpp\n#include <string> // Required for std::string\n\nstd::string post_ops_str = ops_tok.substr(0, POST_OPS_STR_LEN - 1);\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<string>`: Required for `std::string`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-4bceb6a3-70f0-4b70-b8f0-9b9b6f3852d9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used in a way that can lead to buffer overflows or other unintended behavior. In C++, `strncpy` is often used to copy strings, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can lead to vulnerabilities if the destination buffer is used without ensuring it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or C++ string classes (`std::string`) that manage memory automatically and ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Checks**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and prevent such vulnerabilities in the codebase.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative or ensure proper null-termination:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n#define GEMM_TYPE_STR_LEN 100\n\nvoid safeCopy(char* gemm_type_str, const char* ops_tok) {\n    // Use safer alternative or ensure null-termination\n    std::strncpy(gemm_type_str, ops_tok, GEMM_TYPE_STR_LEN - 1);\n    gemm_type_str[GEMM_TYPE_STR_LEN - 1] = '\\0'; // Ensure null-termination\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-5f00ee7b-09a0-4673-a120-8272ec840784",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows or memory corruption. This typically occurs when the size of the data being copied exceeds the size of the destination buffer, or when the source and destination buffers overlap. Such issues can lead to undefined behavior, crashes, or security vulnerabilities such as data leaks or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` if there is a possibility of overlapping buffers.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows.\n4. **Boundary Checks**: Implement boundary checks before performing memory operations.\n5. **Use C++ Standard Library**: Prefer using C++ standard library containers and algorithms which handle memory management automatically.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nmemcpy(c_ref, c, (size_C * sizeof(C_type)));\n```\n\n**Fix:**\n\n1. **Ensure Buffer Size**: Verify that `c_ref` has enough space to accommodate `(size_C * sizeof(C_type))` bytes.\n2. **Use `std::copy`**: If `c` and `c_ref` are arrays or pointers to elements of a type, consider using `std::copy` for safer copying.\n\n```cpp\n#include <algorithm> // for std::copy\n\n// Assuming c and c_ref are pointers to C_type and size_C is the number of elements\nstd::copy(c, c + size_C, c_ref);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<algorithm>`: This library is required for using `std::copy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-44d23e0b-f6e0-40f7-ae10-7ec934e1d872",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used in a way that can lead to buffer overflows or improper null-termination of strings. In C++, `strncpy` is often used to copy strings with a specified maximum length, but it does not guarantee null-termination if the source string is longer than the specified length. This can lead to undefined behavior, including potential security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or C++ standard library functions such as `std::string` which handle memory management and null-termination automatically.\n2. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null-terminator.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability sink:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Original code\n// strncpy(post_ops_str_copy, post_ops_str, POST_OPS_STR_LEN-1);\n\n// Fixed code\nstrncpy(post_ops_str_copy, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_copy[POST_OPS_STR_LEN - 1] = '\\0'; // Ensure null-termination\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-38477e1e-73b2-47e9-9b59-a5425c69dc46",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-4ac09864-7ae5-455e-a1c1-3e9345175ecc",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-9239ca55-7d96-4843-bc56-d100904e57a1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-6be9c4b7-ca2a-4fda-9eb8-bda30bb18629",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-349272cb-5de0-426a-9092-83a2d26ddb4e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or improper memory access. In the provided code snippet, `malloc(n * num_groups * sizeof(float))`, the vulnerability may occur if the multiplication of `n` and `num_groups` results in an integer overflow, leading to insufficient memory allocation and subsequent undefined behavior.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `n` and `num_groups` are within a safe range to prevent integer overflow.\n2. **Use Safer Functions**: Consider using safer alternatives like `calloc` which automatically initializes the allocated memory to zero.\n3. **Check for Overflow**: Before performing the multiplication, check if the result will overflow.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t n = 10; // Example value\n    size_t num_groups = 5; // Example value\n\n    // Check for overflow\n    if (n > 0 && num_groups > 0 && n <= std::numeric_limits<size_t>::max() / num_groups) {\n        float* array = (float*)malloc(n * num_groups * sizeof(float));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-fe115bc8-3887-4120-9fc8-b23c7da7234a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, `malloc(m * num_groups * sizeof(float))`, the vulnerability may occur if the multiplication of `m` and `num_groups` results in an integer overflow, leading to insufficient memory allocation and potential buffer overflow.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `num_groups` are within a safe range to prevent integer overflow.\n2. **Use Safer Functions**: Consider using safer alternatives like `calloc` which automatically initializes the allocated memory to zero.\n3. **Check for Overflow**: Before performing the multiplication, check if the result will overflow.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t m = 10; // Example value\n    size_t num_groups = 20; // Example value\n\n    // Check for overflow\n    if (m > 0 && num_groups > 0 && m <= std::numeric_limits<size_t>::max() / num_groups) {\n        size_t total_size = m * num_groups;\n        float* array = (float*)malloc(total_size * sizeof(float));\n\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To use `std::numeric_limits` for checking overflow.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-cbfe0761-a975-4354-850f-c09dc9c3e774",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. This vulnerability can lead to various issues such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not managed correctly. In the specific case of `malloc(n * num_groups * sizeof(bfloat16))`, the vulnerability may occur due to incorrect calculation of the total memory size needed, potentially leading to insufficient memory allocation or integer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Input**: Ensure that all inputs used in the calculation of memory size are validated to prevent integer overflow.\n2. **Check for Overflow**: Use safe arithmetic operations to check for potential overflows before performing the multiplication.\n3. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n5. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming bfloat16 is a defined type\ntypedef float bfloat16; // Example definition\n\nvoid allocateMemory(size_t n, size_t num_groups) {\n    // Check for potential overflow\n    if (n > 0 && num_groups > 0 && n <= std::numeric_limits<size_t>::max() / num_groups) {\n        size_t total_size = n * num_groups * sizeof(bfloat16);\n        bfloat16* buffer = static_cast<bfloat16*>(malloc(total_size));\n\n        if (buffer == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return;\n        }\n\n        // Use the buffer...\n\n        // Free the allocated memory\n        free(buffer);\n    } else {\n        std::cerr << \"Integer overflow detected or invalid input\" << std::endl;\n    }\n}\n\nint main() {\n    size_t n = 10;\n    size_t num_groups = 5;\n    allocateMemory(n, num_groups);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To use `std::numeric_limits` for checking maximum size limits.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-7f332897-f5d7-4120-b90c-b4739ebca626",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to memory allocation issues such as buffer overflows, memory leaks, or improper memory access. In the provided code snippet, the expression `malloc(m * num_groups * sizeof(bfloat16))` is used to allocate memory. If the values of `m` or `num_groups` are not properly validated, this can result in an integer overflow, leading to insufficient memory allocation and potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `num_groups` are validated to prevent integer overflow. They should be within a reasonable range and should not cause the multiplication to exceed the maximum value of `size_t`.\n\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n3. **Use Safer Functions**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n\n4. **Integer Overflow Checks**: Before performing the multiplication, check if the result will overflow.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming bfloat16 is a defined type\ntypedef float bfloat16; // Example definition\n\nvoid allocateMemory(size_t m, size_t num_groups) {\n    // Check for potential overflow\n    if (m > 0 && num_groups > 0 && m <= std::numeric_limits<size_t>::max() / num_groups) {\n        size_t total_size = m * num_groups * sizeof(bfloat16);\n        bfloat16* buffer = (bfloat16*)malloc(total_size);\n\n        if (buffer == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            // Handle allocation failure\n        } else {\n            // Use the buffer\n            // ...\n\n            // Free the allocated memory\n            free(buffer);\n        }\n    } else {\n        std::cerr << \"Integer overflow detected or invalid input\" << std::endl;\n    }\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t num_groups = 5; // Example value\n    allocateMemory(m, num_groups);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To use `std::numeric_limits` for checking maximum size.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-0c8bffd9-ce04-4e9f-8785-36515dd16f0a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the specific case of `malloc(sizeof(aocl_pre_op_sf))`, the vulnerability may occur if `aocl_pre_op_sf` is not a type but rather a variable or an expression, leading to incorrect memory allocation size. This can result in buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Size Calculation**: Always use `sizeof` with the type, not the variable, to ensure the correct amount of memory is allocated.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage memory automatically.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or `memset` to initialize allocated memory to prevent undefined behavior from uninitialized memory access.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <cstring>  // For memset\n\n// Assuming aocl_pre_op_sf is a type\ntypedef struct {\n    // Structure members\n} aocl_pre_op_sf;\n\nint main() {\n    // Correct usage of malloc with sizeof(type)\n    aocl_pre_op_sf* ptr = (aocl_pre_op_sf*)malloc(sizeof(aocl_pre_op_sf));\n    \n    if (ptr == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize allocated memory\n    memset(ptr, 0, sizeof(aocl_pre_op_sf));\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-787c8b36-066c-45c4-be50-4c36c9ab7bb9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the specific case of `malloc(sizeof(aocl_pre_op_sf))`, the vulnerability may occur if `aocl_pre_op_sf` is not a type but rather a variable or an expression, leading to incorrect memory allocation size. This can result in buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Size Calculation**: Always use `sizeof` with the type, not the variable, to ensure the correct amount of memory is allocated.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage memory automatically.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or `memset` to initialize allocated memory to prevent undefined behavior from uninitialized memory access.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <cstring>  // For memset\n\n// Assuming aocl_pre_op_sf is a type\ntypedef struct {\n    // Structure members\n} aocl_pre_op_sf;\n\nint main() {\n    // Correct usage of malloc with sizeof(type)\n    aocl_pre_op_sf* ptr = (aocl_pre_op_sf*)malloc(sizeof(aocl_pre_op_sf));\n    \n    if (ptr == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize allocated memory\n    memset(ptr, 0, sizeof(aocl_pre_op_sf));\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-26045042-3720-4e6b-af8f-f3cceee34eb0",
              "help": {
                "text": "",
                "markdown": "### Detected Issue with C Function (malloc) Vulnerability in C++\n\nThe vulnerability arises from the improper use of the `malloc` function in C++, specifically when allocating memory for a data structure or object. In the provided example, `malloc(sizeof(aocl_group_post_op))` is used, which can lead to several issues:\n\n1. **Incorrect Size Calculation**: If `aocl_group_post_op` is a type or a pointer, `sizeof` might not return the expected size, leading to insufficient memory allocation.\n2. **Type Safety**: `malloc` returns a `void*`, which requires explicit casting, potentially leading to type safety issues.\n3. **Memory Leaks**: If the allocated memory is not properly managed or freed, it can lead to memory leaks.\n\n### General Mitigation Advice\n\n- **Use `new` Operator**: In C++, prefer using the `new` operator for memory allocation, which is type-safe and automatically calculates the correct size.\n- **Check for Null Pointers**: Always check if the memory allocation was successful by verifying that the pointer is not `NULL`.\n- **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed using `delete` or `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nReplace the `malloc` call with the `new` operator for better type safety and automatic size calculation:\n\n```cpp\n#include <iostream>\n\n// Assuming aocl_group_post_op is a struct or class\nstruct aocl_group_post_op {\n    // Members of the struct\n};\n\nint main() {\n    // Use new instead of malloc\n    aocl_group_post_op* post_op = new aocl_group_post_op;\n\n    // Check if allocation was successful\n    if (!post_op) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    delete post_op;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe above code does not require any additional library dependencies beyond the standard C++ library.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-65c2dff5-56ce-40ef-ba20-9fa3d2a5e3f7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, the expression used in `malloc` may result in incorrect memory allocation if the calculated size exceeds the available memory or if the multiplication results in an integer overflow.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in size calculations are validated to prevent integer overflow.\n2. **Use Safe Functions**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Limit Memory Usage**: Implement limits on memory allocation to prevent excessive memory usage.\n\n### Source Code Fix Recommendation\n\nTo mitigate the specific vulnerability in the code snippet, you can perform checks to prevent integer overflow and ensure successful memory allocation:\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming bfloat16 is defined elsewhere\ntypedef float bfloat16; // Example definition\n\nvoid* safe_malloc(size_t num_groups, size_t scale_factor_len) {\n    size_t max_size = std::numeric_limits<size_t>::max() / sizeof(bfloat16);\n    if (num_groups > max_size / scale_factor_len) {\n        std::cerr << \"Integer overflow detected during memory allocation.\" << std::endl;\n        return nullptr;\n    }\n\n    size_t total_size = num_groups * scale_factor_len * sizeof(bfloat16);\n    void* ptr = malloc(total_size);\n    if (!ptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n    }\n    return ptr;\n}\n\nint main() {\n    size_t num_groups = 10; // Example value\n    size_t scale_factor_len = 20; // Example value\n\n    bfloat16* data = static_cast<bfloat16*>(safe_malloc(num_groups, scale_factor_len));\n    if (data) {\n        // Use the allocated memory\n        free(data);\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access numeric limits for data types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-80a6266c-276f-4a2d-86e4-ff33f119ce5a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, the expression used in `malloc`:\n\n```c\nmalloc(num_groups * scale_factor_len * sizeof(float))\n```\n\ncan lead to an integer overflow if the product of `num_groups` and `scale_factor_len` exceeds the maximum value representable by an `int`. This overflow can result in allocating less memory than intended, leading to buffer overflows when the allocated memory is accessed.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `num_groups` and `scale_factor_len` are within a safe range to prevent integer overflow.\n2. **Use Safer Functions**: Consider using safer memory allocation functions that check for overflow, such as `calloc`, which also initializes the allocated memory to zero.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Smart Pointers**: In C++, prefer using smart pointers (e.g., `std::unique_ptr`, `std::shared_ptr`) to manage dynamic memory automatically.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, you can use `calloc` to allocate memory safely and check for potential overflows:\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nvoid allocateMemory(size_t num_groups, size_t scale_factor_len) {\n    if (num_groups > 0 && scale_factor_len > 0 &&\n        num_groups <= std::numeric_limits<size_t>::max() / scale_factor_len) {\n        float* data = (float*)calloc(num_groups * scale_factor_len, sizeof(float));\n        if (data == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return;\n        }\n        // Use the allocated memory\n        // ...\n\n        // Free the allocated memory\n        free(data);\n    } else {\n        std::cerr << \"Integer overflow detected or invalid input\" << std::endl;\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: For checking the maximum value of `size_t`.\n- `<cstdlib>`: For memory allocation functions like `calloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-47bd0729-1672-4541-b7d0-7a4e386ebe4c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper memory allocation using the `malloc` function. In this specific case, the vulnerability is due to the incorrect size being passed to `malloc`. The expression `malloc(sizeof(aocl_pre_op_sf))` is used, which may not allocate the correct amount of memory if `aocl_pre_op_sf` is a pointer or an incomplete type. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used on the correct type. If `aocl_pre_op_sf` is a pointer, use the type it points to.\n2. **Prefer `new` in C++**: In C++, prefer using `new` and `delete` for memory management instead of `malloc` and `free`.\n3. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n4. **Use Smart Pointers**: Consider using smart pointers like `std::unique_ptr` or `std::shared_ptr` for automatic memory management.\n\n### Source Code Fix Recommendation\n\nAssuming `aocl_pre_op_sf` is a type and not a pointer, the correct usage would be:\n\n```cpp\n#include <cstdlib> // for malloc and free\n\n// Assuming aocl_pre_op_sf is a type\naocl_pre_op_sf* ptr = (aocl_pre_op_sf*)malloc(sizeof(aocl_pre_op_sf));\nif (ptr == NULL) {\n    // Handle allocation failure\n}\n\n// Use the allocated memory\n\nfree(ptr);\n```\n\nIf `aocl_pre_op_sf` is a pointer type, ensure you allocate the correct size:\n\n```cpp\n#include <cstdlib> // for malloc and free\n\n// Assuming aocl_pre_op_sf is a pointer to a type\naocl_pre_op_sf* ptr = (aocl_pre_op_sf*)malloc(sizeof(*ptr));\nif (ptr == NULL) {\n    // Handle allocation failure\n}\n\n// Use the allocated memory\n\nfree(ptr);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstdlib>`: This library is required for using `malloc` and `free`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-019a6c69-c4dd-4bce-abbc-02bcb17d9e0a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, the expression `malloc(num_groups * zp_vec_length * sizeof(int8_t))` is used to allocate memory. If `num_groups` or `zp_vec_length` are not properly validated, this can result in an integer overflow, leading to insufficient memory allocation and potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in memory allocation calculations are validated to prevent integer overflow.\n2. **Use Safer Functions**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Limit Memory Usage**: Implement limits on the maximum amount of memory that can be allocated to prevent excessive memory usage.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t num_groups = /* some value */;\n    size_t zp_vec_length = /* some value */;\n\n    // Check for potential overflow\n    if (num_groups > 0 && zp_vec_length > 0 && \n        num_groups <= std::numeric_limits<size_t>::max() / zp_vec_length) {\n        \n        size_t total_size = num_groups * zp_vec_length * sizeof(int8_t);\n        int8_t* buffer = static_cast<int8_t*>(malloc(total_size));\n\n        if (buffer == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n        // Use the buffer...\n\n        free(buffer);\n    } else {\n        std::cerr << \"Invalid input size, potential overflow detected\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To use `std::numeric_limits` for checking potential overflow.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-e78ba5c0-f756-4678-abcb-45ffe5f20b37",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(sizeof(aocl_pre_op_zp))`, the vulnerability may occur if `aocl_pre_op_zp` is a pointer or an incomplete type, leading to incorrect memory allocation size. This can result in insufficient memory being allocated, causing potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Size Calculation**: Always ensure that the size passed to `malloc` is correct. If `aocl_pre_op_zp` is a pointer, use the size of the type it points to.\n2. **Use `sizeof` Correctly**: Use `sizeof(*aocl_pre_op_zp)` if `aocl_pre_op_zp` is a pointer to allocate memory for the type it points to.\n3. **Check for NULL**: Always check the return value of `malloc` for `NULL` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers for automatic memory management.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for malloc\n#include <iostream> // for std::cerr\n\n// Assuming aocl_pre_op_zp is a pointer to a type, e.g., int\ntypedef int aocl_pre_op_zp; // Example type definition\n\nint main() {\n    // Corrected memory allocation\n    aocl_pre_op_zp* ptr = (aocl_pre_op_zp*)malloc(sizeof(aocl_pre_op_zp));\n    \n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input/output operations, such as error messages.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-161ad327-7531-411d-b24b-27205ff4ef7c",
              "help": {
                "text": "",
                "markdown": "### Detected Issue with C Function (malloc) Vulnerability in C++\n\nThe vulnerability arises from the improper use of the `malloc` function in C++, specifically when allocating memory for a data structure or object. The issue is that `malloc` is being used with `sizeof(aocl_pre_op)`, which may not correctly allocate the required memory if `aocl_pre_op` is a pointer or an incomplete type. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Use `new` Operator**: In C++, prefer using the `new` operator for memory allocation, which automatically calculates the correct size for the object.\n2. **Check for NULL**: Always check the result of `malloc` for `NULL` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used on the correct type, especially if `aocl_pre_op` is a pointer or an incomplete type.\n4. **Initialize Memory**: Consider using `calloc` instead of `malloc` if you need the memory to be initialized to zero.\n5. **Free Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n\n// Assuming aocl_pre_op is a struct or class\nstruct aocl_pre_op {\n    // Members of the struct\n};\n\nint main() {\n    // Correct usage of malloc\n    aocl_pre_op* ptr = (aocl_pre_op*)malloc(sizeof(aocl_pre_op));\n    if (ptr == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstdlib>`: This library is required for using `malloc` and `free` functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-bb793964-5c80-412a-8485-64ff30c02df1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This can occur if the size calculation for `malloc` is incorrect, leading to insufficient memory allocation. In the provided example, the expression `malloc(n_scale * sizeof(DSCALE_type))` may be vulnerable if `n_scale` is not properly validated or if `DSCALE_type` is not correctly defined, leading to potential security risks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `n_scale` is validated to be within a safe range to prevent excessive memory allocation.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `calloc` for zero-initialized memory allocation or smart pointers in C++ for automatic memory management.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <iostream> // For std::cerr\n\ntypedef int DSCALE_type; // Example type definition\n\nvoid exampleFunction(size_t n_scale) {\n    // Validate n_scale to prevent excessive allocation\n    if (n_scale == 0 || n_scale > SIZE_MAX / sizeof(DSCALE_type)) {\n        std::cerr << \"Invalid scale size\" << std::endl;\n        return;\n    }\n\n    // Allocate memory safely\n    DSCALE_type* scaleArray = static_cast<DSCALE_type*>(malloc(n_scale * sizeof(DSCALE_type)));\n    if (scaleArray == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(scaleArray);\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-93e35cb0-7111-4e5a-9733-38d74e0a8d72",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. Specifically, the use of `malloc(m * n * sizeof(float))` can be problematic if the multiplication of `m` and `n` results in an integer overflow, causing `malloc` to allocate insufficient memory. This can lead to writing beyond the allocated memory space, resulting in a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Check for Integer Overflow**: Before performing the multiplication, ensure that the result will not exceed the maximum value representable by the data type.\n2. **Use Safer Functions**: Consider using safer alternatives or libraries that handle memory allocation more securely.\n3. **Validate Input**: Ensure that the values of `m` and `n` are within expected ranges and are not negative.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nbool safeMultiply(size_t a, size_t b, size_t& result) {\n    if (a == 0 || b == 0) {\n        result = 0;\n        return true;\n    }\n    if (a > std::numeric_limits<size_t>::max() / b) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safeMultiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    float* array = static_cast<float*>(malloc(size * sizeof(float)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the array...\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-198bb2c5-9601-495f-83a8-cbaaf4f64429",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to various issues such as buffer overflows, memory leaks, or integer overflows. In the specific case of `malloc(m * n * sizeof(C_DSCALE_type))`, the vulnerability may occur if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation. This can cause undefined behavior, potentially allowing attackers to exploit the program.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory allocation more safely.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming C_DSCALE_type is defined somewhere\ntypedef int C_DSCALE_type;\n\nbool safe_multiply(size_t a, size_t b, size_t& result) {\n    if (a > 0 && b > 0 && a > (std::numeric_limits<size_t>::max() / b)) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safe_multiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected during multiplication!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    void* ptr = malloc(size * sizeof(C_DSCALE_type));\n    if (!ptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    free(ptr);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access numeric limits for data types.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-9b61ec4a-b913-4cab-b6d2-a0295a9f7e27",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory leaks. Specifically, the expression `malloc(m * n * sizeof(int32_t))` can be vulnerable if the multiplication `m * n` results in an integer overflow, causing `malloc` to allocate less memory than intended. This can lead to writing beyond the allocated memory, resulting in undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Alternative Functions**: Consider using functions like `calloc` which automatically handle multiplication and zero-initialize the allocated memory.\n4. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    int32_t m = 1000; // Example values\n    int32_t n = 2000;\n\n    // Check for potential overflow\n    if (m > 0 && n > 0 && m <= std::numeric_limits<int32_t>::max() / n) {\n        int32_t* array = static_cast<int32_t*>(malloc(m * n * sizeof(int32_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access numeric limits of data types.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-9f3c0d8b-5886-417c-a021-f3fad4329a56",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or other undefined behaviors. Specifically, the expression `malloc(m * n * sizeof(int8_t))` can be problematic if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation and subsequent memory corruption when the allocated memory is accessed.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory management more safely.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n\n    // Check for overflow before multiplication\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        int8_t* array = static_cast<int8_t*>(malloc(m * n * sizeof(int8_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-9984e0c8-987c-4ed2-b5ab-239f79e80827",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or other undefined behaviors. Specifically, the expression `malloc(m * n * sizeof(int8_t))` can be problematic if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation and subsequent memory corruption when the allocated memory is accessed.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory management more safely.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n\n    // Check for overflow before multiplication\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        int8_t* array = static_cast<int8_t*>(malloc(m * n * sizeof(int8_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-45436562-34cd-4057-816b-3dd8f0a8f413",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory leaks. Specifically, the expression `malloc(m * n * sizeof(int32_t))` can be vulnerable if the multiplication `m * n` results in an integer overflow, causing `malloc` to allocate less memory than intended. This can lead to writing beyond the allocated memory, resulting in undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Alternative Functions**: Consider using functions like `calloc` which automatically handle multiplication and zero-initialize the allocated memory.\n4. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    int32_t m = 1000; // Example values\n    int32_t n = 2000;\n\n    // Check for potential overflow\n    if (m > 0 && n > 0 && m <= std::numeric_limits<int32_t>::max() / n) {\n        int32_t* array = static_cast<int32_t*>(malloc(m * n * sizeof(int32_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access numeric limits of data types.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-14564e97-1f09-4e1a-aa95-861b9cefc07c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. Specifically, the use of `malloc(m * n * sizeof(float))` can be problematic if the multiplication of `m` and `n` results in an integer overflow, causing `malloc` to allocate insufficient memory. This can lead to writing beyond the allocated memory space, resulting in a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Check for Integer Overflow**: Before performing the multiplication, ensure that the result will not exceed the maximum value representable by the data type.\n2. **Use Safer Functions**: Consider using safer alternatives or libraries that handle memory allocation more securely.\n3. **Validate Input**: Ensure that the values of `m` and `n` are within expected ranges and are not negative.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nbool safeMultiply(size_t a, size_t b, size_t& result) {\n    if (a == 0 || b == 0) {\n        result = 0;\n        return true;\n    }\n    if (a > std::numeric_limits<size_t>::max() / b) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safeMultiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    float* array = static_cast<float*>(malloc(size * sizeof(float)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the array...\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f2d80fd4-bec0-43d9-a1aa-a51826cc41e4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory corruption. Specifically, when using `malloc` to allocate memory, if the multiplication of the dimensions (`m * n * sizeof(bfloat16)`) results in an integer overflow, it can lead to allocating less memory than intended. This can cause buffer overflows when the program writes beyond the allocated memory, leading to undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Safer Functions**: Consider using safer memory allocation functions or libraries that handle overflow checks internally.\n4. **Static Analysis Tools**: Utilize static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of integer overflow in the `malloc` call, you can implement a check before performing the multiplication:\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming bfloat16 is a defined type\ntypedef float bfloat16;\n\nvoid* safeMalloc(size_t m, size_t n) {\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        size_t totalSize = m * n * sizeof(bfloat16);\n        return malloc(totalSize);\n    } else {\n        std::cerr << \"Integer overflow detected or invalid size parameters.\" << std::endl;\n        return nullptr;\n    }\n}\n\nint main() {\n    size_t m = 1000;\n    size_t n = 1000;\n    bfloat16* array = static_cast<bfloat16*>(safeMalloc(m, n));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    // Use the allocated memory\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-b989a44a-3101-4efa-b82e-f92c583d205f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(sizeof(aocl_post_op_matrix_mul))`, the vulnerability may occur if the size of the type `aocl_post_op_matrix_mul` is not correctly calculated or if the type is not properly defined, leading to incorrect memory allocation.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct type or variable to allocate the appropriate amount of memory.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to ensure that memory allocation was successful.\n3. **Initialize Memory**: Consider using `calloc` instead of `malloc` to automatically initialize the allocated memory to zero.\n4. **Free Memory**: Ensure that all dynamically allocated memory is freed when no longer needed to prevent memory leaks.\n5. **Use Smart Pointers**: In C++, prefer using smart pointers (e.g., `std::unique_ptr`, `std::shared_ptr`) to manage dynamic memory automatically.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for malloc and free\n#include <iostream>\n\n// Assuming aocl_post_op_matrix_mul is a defined struct or class\nstruct aocl_post_op_matrix_mul {\n    // member variables\n};\n\nint main() {\n    // Correctly allocate memory for aocl_post_op_matrix_mul\n    aocl_post_op_matrix_mul* ptr = static_cast<aocl_post_op_matrix_mul*>(malloc(sizeof(aocl_post_op_matrix_mul)));\n    \n    // Check if malloc succeeded\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-bc7d0891-2757-46fc-9f94-49a2df66b046",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This can occur if the size calculation for `malloc` is incorrect, leading to insufficient memory allocation. In the provided example, the expression `malloc(n_scale * sizeof(DSCALE_type))` may be vulnerable if `n_scale` is not properly validated or if `DSCALE_type` is not correctly defined, leading to potential security risks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `n_scale` is validated to be within a safe range to prevent excessive memory allocation.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `calloc` for zero-initialized memory allocation or smart pointers in C++ for automatic memory management.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <iostream> // For std::cerr\n\ntypedef int DSCALE_type; // Example type definition\n\nvoid exampleFunction(size_t n_scale) {\n    // Validate n_scale to prevent excessive allocation\n    if (n_scale == 0 || n_scale > SIZE_MAX / sizeof(DSCALE_type)) {\n        std::cerr << \"Invalid scale size\" << std::endl;\n        return;\n    }\n\n    // Allocate memory safely\n    DSCALE_type* scaleArray = static_cast<DSCALE_type*>(malloc(n_scale * sizeof(DSCALE_type)));\n    if (scaleArray == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(scaleArray);\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-470ac4c8-90f4-47ec-93c9-58ed685b1d00",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. Specifically, the use of `malloc(m * n * sizeof(float))` can be problematic if the multiplication of `m` and `n` results in an integer overflow, causing `malloc` to allocate insufficient memory. This can lead to writing beyond the allocated memory space, resulting in a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Check for Integer Overflow**: Before performing the multiplication, ensure that the result will not exceed the maximum value representable by the data type.\n2. **Use Safer Functions**: Consider using safer alternatives or libraries that handle memory allocation more securely.\n3. **Validate Input**: Ensure that the values of `m` and `n` are within expected ranges and are not negative.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nbool safeMultiply(size_t a, size_t b, size_t& result) {\n    if (a == 0 || b == 0) {\n        result = 0;\n        return true;\n    }\n    if (a > std::numeric_limits<size_t>::max() / b) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safeMultiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    float* array = static_cast<float*>(malloc(size * sizeof(float)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the array...\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-8fcf436b-ee3e-4dfc-950f-d3a1ab6a4ebd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to various issues such as buffer overflows, memory leaks, or integer overflows. In the specific case of `malloc(m * n * sizeof(C_DSCALE_type))`, the vulnerability may occur if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation. This can cause undefined behavior, potentially allowing attackers to exploit the program.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory allocation more safely.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming C_DSCALE_type is defined somewhere\ntypedef int C_DSCALE_type;\n\nbool safe_multiply(size_t a, size_t b, size_t& result) {\n    if (a > 0 && b > 0 && a > (std::numeric_limits<size_t>::max() / b)) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safe_multiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected during multiplication!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    void* ptr = malloc(size * sizeof(C_DSCALE_type));\n    if (!ptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    free(ptr);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access numeric limits for data types.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-373633a5-e19d-456f-b089-a81f4678c1d2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory leaks. Specifically, the expression `malloc(m * n * sizeof(int32_t))` can be vulnerable if the multiplication `m * n` results in an integer overflow, causing `malloc` to allocate less memory than intended. This can lead to writing beyond the allocated memory, resulting in undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Alternative Functions**: Consider using functions like `calloc` which automatically handle multiplication and zero-initialize the allocated memory.\n4. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    int32_t m = 1000; // Example values\n    int32_t n = 2000;\n\n    // Check for potential overflow\n    if (m > 0 && n > 0 && m <= std::numeric_limits<int32_t>::max() / n) {\n        int32_t* array = static_cast<int32_t*>(malloc(m * n * sizeof(int32_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access numeric limits of data types.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-e9151b79-6d5e-4aaf-ae1e-5eb46b6df627",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or other undefined behaviors. Specifically, the expression `malloc(m * n * sizeof(int8_t))` can be problematic if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation and subsequent memory corruption when the allocated memory is accessed.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory management more safely.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n\n    // Check for overflow before multiplication\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        int8_t* array = static_cast<int8_t*>(malloc(m * n * sizeof(int8_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-66682820-3120-40c0-958b-8dbf790faceb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or other undefined behaviors. Specifically, the expression `malloc(m * n * sizeof(int8_t))` can be problematic if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation and subsequent memory corruption when the allocated memory is accessed.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory management more safely.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n\n    // Check for overflow before multiplication\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        int8_t* array = static_cast<int8_t*>(malloc(m * n * sizeof(int8_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-e1139c20-8708-41d4-9102-a3fa6f2ee06b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory leaks. Specifically, the expression `malloc(m * n * sizeof(int32_t))` can be vulnerable if the multiplication `m * n` results in an integer overflow, causing `malloc` to allocate less memory than intended. This can lead to writing beyond the allocated memory, resulting in undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Alternative Functions**: Consider using functions like `calloc` which automatically handle multiplication and zero-initialize the allocated memory.\n4. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    int32_t m = 1000; // Example values\n    int32_t n = 2000;\n\n    // Check for potential overflow\n    if (m > 0 && n > 0 && m <= std::numeric_limits<int32_t>::max() / n) {\n        int32_t* array = static_cast<int32_t*>(malloc(m * n * sizeof(int32_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access numeric limits of data types.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f5e28b88-1a3a-4093-aba6-fbbfdf1c03f2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. Specifically, the use of `malloc(m * n * sizeof(float))` can be problematic if the multiplication of `m` and `n` results in an integer overflow, causing `malloc` to allocate insufficient memory. This can lead to writing beyond the allocated memory space, resulting in a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Check for Integer Overflow**: Before performing the multiplication, ensure that the result will not exceed the maximum value representable by the data type.\n2. **Use Safer Functions**: Consider using safer alternatives or libraries that handle memory allocation more securely.\n3. **Validate Input**: Ensure that the values of `m` and `n` are within expected ranges and are not negative.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nbool safeMultiply(size_t a, size_t b, size_t& result) {\n    if (a == 0 || b == 0) {\n        result = 0;\n        return true;\n    }\n    if (a > std::numeric_limits<size_t>::max() / b) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safeMultiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    float* array = static_cast<float*>(malloc(size * sizeof(float)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the array...\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-c8277517-beb3-4fe0-bf7d-ffcb3c9db184",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory corruption. Specifically, when using `malloc` to allocate memory, if the multiplication of the dimensions (`m * n * sizeof(bfloat16)`) results in an integer overflow, it can lead to allocating less memory than intended. This can cause buffer overflows when the program writes beyond the allocated memory, leading to undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Safer Functions**: Consider using safer memory allocation functions or libraries that handle overflow checks internally.\n4. **Static Analysis Tools**: Utilize static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of integer overflow in the `malloc` call, you can implement a check before performing the multiplication:\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming bfloat16 is a defined type\ntypedef float bfloat16;\n\nvoid* safeMalloc(size_t m, size_t n) {\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        size_t totalSize = m * n * sizeof(bfloat16);\n        return malloc(totalSize);\n    } else {\n        std::cerr << \"Integer overflow detected or invalid size parameters.\" << std::endl;\n        return nullptr;\n    }\n}\n\nint main() {\n    size_t m = 1000;\n    size_t n = 1000;\n    bfloat16* array = static_cast<bfloat16*>(safeMalloc(m, n));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    // Use the allocated memory\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f31da6f0-8279-4e1e-b410-f376e19c6cd2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper memory allocation using the `malloc` function. In the provided code snippet, the vulnerability is due to the incorrect use of `sizeof` with a type instead of an instance. Specifically, `malloc(sizeof(aocl_post_op_matrix_add))` should allocate memory based on the size of the type `aocl_post_op_matrix_add`, but if `aocl_post_op_matrix_add` is a pointer or an incomplete type, this can lead to incorrect memory allocation, potentially causing buffer overflows or memory corruption.\n\n### General Mitigation Advice\n\n1. **Correct Use of `sizeof`:** Ensure that `sizeof` is used with the correct type or instance to allocate the appropriate amount of memory.\n2. **Check for NULL:** Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives:** Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers for automatic memory management.\n4. **Initialize Allocated Memory:** Use functions like `calloc` or `memset` to initialize allocated memory to prevent undefined behavior from uninitialized memory access.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // For malloc and free\n#include <cstring> // For memset\n\n// Assuming aocl_post_op_matrix_add is a struct or class\nstruct aocl_post_op_matrix_add {\n    // Members of the struct\n};\n\nint main() {\n    // Correct use of sizeof with the type\n    aocl_post_op_matrix_add* ptr = (aocl_post_op_matrix_add*)malloc(sizeof(aocl_post_op_matrix_add));\n    \n    if (ptr == nullptr) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize allocated memory\n    memset(ptr, 0, sizeof(aocl_post_op_matrix_add));\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-bceb65d7-cbc0-4496-9ad8-890ac17b2a02",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the provided code snippet, `malloc( n_zp * sizeof( C_DSCALE_type )`, the vulnerability may occur if `n_zp` is not properly validated, leading to potential issues such as integer overflow, buffer overflow, or memory allocation failures. These issues can result in undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in memory allocation calculations are validated to prevent integer overflow or underflow.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` or `std::unique_ptr` for automatic memory management.\n4. **Limit Memory Usage**: Implement limits on memory allocation to prevent excessive memory usage that could lead to denial of service.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // for malloc and free\n\n// Assuming C_DSCALE_type is a defined type\ntypedef int C_DSCALE_type;\n\nvoid allocateMemory(size_t n_zp) {\n    // Validate n_zp to prevent integer overflow\n    if (n_zp == 0 || n_zp > SIZE_MAX / sizeof(C_DSCALE_type)) {\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return;\n    }\n\n    // Allocate memory\n    C_DSCALE_type* ptr = static_cast<C_DSCALE_type*>(malloc(n_zp * sizeof(C_DSCALE_type)));\n    \n    // Check if malloc succeeded\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(ptr);\n}\n\nint main() {\n    size_t n_zp = 10; // Example size\n    allocateMemory(n_zp);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-399dcbe2-6ecd-4cd6-9f9f-ab7f9297f9e4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. This vulnerability can lead to various issues such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not properly managed. Specifically, the vulnerability sink `malloc(n_zp * sizeof(uint8_t))` can cause problems if `n_zp` is not properly validated, potentially leading to an integer overflow or allocation of insufficient memory.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the value of `n_zp` is validated before using it in the `malloc` function. It should be a positive integer and within a reasonable range to prevent integer overflow.\n\n2. **Check for NULL**: Always check the return value of `malloc`. If it returns `NULL`, it indicates that the memory allocation failed, and the program should handle this gracefully.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n\n4. **Free Allocated Memory**: Ensure that any memory allocated with `malloc` is properly freed using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    size_t n_zp = 10; // Example value, should be validated\n    if (n_zp == 0 || n_zp > SIZE_MAX / sizeof(uint8_t)) {\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    uint8_t* buffer = static_cast<uint8_t*>(malloc(n_zp * sizeof(uint8_t)));\n    if (buffer == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the buffer...\n\n    free(buffer);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-58ffe852-1d3b-46a0-ba1e-0a699f46c6e7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. In the provided code snippet, `malloc( n_zp * sizeof( int8_t )`, the vulnerability may occur if `n_zp` is not properly validated. This can lead to integer overflow, resulting in insufficient memory allocation, buffer overflows, or memory corruption.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `n_zp` is validated to be a positive integer and within a reasonable range to prevent integer overflow.\n2. **Use Safer Alternatives**: Consider using `new` in C++ or `std::vector` for dynamic memory allocation, which provides automatic memory management and bounds checking.\n3. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Free Allocated Memory**: Ensure that any allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    size_t n_zp = 10; // Example value, ensure this is validated\n    if (n_zp > SIZE_MAX / sizeof(int8_t)) {\n        std::cerr << \"Size too large, potential overflow detected.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    int8_t* array = static_cast<int8_t*>(malloc(n_zp * sizeof(int8_t)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-49f3cadc-74c6-4460-b577-9e98162cbbf9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or improper handling of memory allocation failures. In the specific case of `malloc( n_zp * sizeof( int32_t )`, the vulnerability may occur if `n_zp` is not properly validated, leading to an incorrect or excessive amount of memory being allocated. This can result in undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in memory allocation calculations are validated to prevent excessive or negative values.\n2. **Check for Allocation Failure**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using safer memory allocation functions like `calloc`, which initializes the allocated memory to zero, or C++ alternatives like `new` which throw exceptions on failure.\n4. **Limit Memory Usage**: Implement limits on the amount of memory that can be allocated to prevent resource exhaustion.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    size_t n_zp = 10; // Example value, should be validated\n    if (n_zp > SIZE_MAX / sizeof(int32_t)) {\n        std::cerr << \"Requested size is too large.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    int32_t* array = static_cast<int32_t*>(malloc(n_zp * sizeof(int32_t)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For memory allocation functions and exit codes.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-66610a6c-0433-4fc3-9590-0d300def46c5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, `malloc( n_zp * sizeof( float )`, the vulnerability may occur if `n_zp` is not properly validated, leading to an incorrect amount of memory being allocated. This can result in insufficient memory allocation or excessive memory allocation, both of which can be exploited by attackers.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in memory allocation are validated to prevent excessive or insufficient allocation.\n2. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using safer alternatives like `new` in C++ which automatically throws an exception on failure.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n_zp = 10; // Example size, should be validated\n    if (n_zp == 0 || n_zp > SIZE_MAX / sizeof(float)) {\n        std::cerr << \"Invalid size for memory allocation\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    float* array = static_cast<float*>(malloc(n_zp * sizeof(float)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    free(array); // Free the allocated memory\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-0d8ff4e9-bbb5-4f84-b4cd-883560c16a80",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc( n_zp * sizeof( bfloat16 )`, the vulnerability may occur if `n_zp` is not properly validated, leading to an incorrect or excessive memory allocation. This can result in security vulnerabilities such as arbitrary code execution or denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in memory allocation are validated to prevent excessive or negative values.\n2. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using safer memory allocation functions like `calloc`, which initializes the allocated memory to zero.\n4. **Limit Memory Usage**: Implement limits on memory allocation to prevent excessive memory usage.\n5. **Code Review and Testing**: Regularly review and test code to identify and fix potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\ntypedef struct {\n    // Define the structure of bfloat16 if necessary\n} bfloat16;\n\nint main() {\n    size_t n_zp = 10; // Example value, should be validated\n    if (n_zp > SIZE_MAX / sizeof(bfloat16)) {\n        std::cerr << \"Requested allocation size is too large.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    bfloat16* buffer = (bfloat16*)malloc(n_zp * sizeof(bfloat16));\n    if (buffer == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the buffer\n\n    free(buffer);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-646148b0-cb90-4288-9b0d-9133c593146f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This can occur if the size calculation for `malloc` is incorrect, leading to insufficient memory allocation. In the provided example, the expression `malloc(n_scale * sizeof(DSCALE_type))` may be vulnerable if `n_scale` is not properly validated or if `DSCALE_type` is not correctly defined, leading to potential security risks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `n_scale` is validated to be within a safe range to prevent excessive memory allocation.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `calloc` for zero-initialized memory allocation or smart pointers in C++ for automatic memory management.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <iostream> // For std::cerr\n\ntypedef int DSCALE_type; // Example type definition\n\nvoid exampleFunction(size_t n_scale) {\n    // Validate n_scale to prevent excessive allocation\n    if (n_scale == 0 || n_scale > SIZE_MAX / sizeof(DSCALE_type)) {\n        std::cerr << \"Invalid scale size\" << std::endl;\n        return;\n    }\n\n    // Allocate memory safely\n    DSCALE_type* scaleArray = static_cast<DSCALE_type*>(malloc(n_scale * sizeof(DSCALE_type)));\n    if (scaleArray == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(scaleArray);\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-6946eb59-3138-4f45-8055-eed7a9380736",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided code snippet, `malloc(sizeof(aocl_post_op_sum))` is used, which can lead to incorrect memory allocation if `aocl_post_op_sum` is a type rather than an instance. This can result in undefined behavior, memory corruption, or application crashes.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct operand. If `aocl_post_op_sum` is a type, use `sizeof(type)`; if it's an instance, use `sizeof(instance)`.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for memory management, as they are type-safe and provide constructors and destructors.\n\n### Source Code Fix Recommendation\n\nIf `aocl_post_op_sum` is a type, the correct usage would be:\n\n```cpp\n#include <cstdlib> // Required for malloc\n\n// Assuming aocl_post_op_sum is a type\naocl_post_op_sum* ptr = (aocl_post_op_sum*)malloc(sizeof(aocl_post_op_sum));\nif (ptr == NULL) {\n    // Handle allocation failure\n}\n```\n\nAlternatively, using C++'s `new`:\n\n```cpp\n// Assuming aocl_post_op_sum is a type\naocl_post_op_sum* ptr = new aocl_post_op_sum();\nif (ptr == nullptr) {\n    // Handle allocation failure\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstdlib>`: This library is required for using `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-aad1ca29-7141-4c44-b165-1a81baae98e7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc( sizeof( float )` is missing a closing parenthesis, which can cause a compilation error. Even if corrected, improper use of `malloc` can lead to memory leaks, buffer overflows, or undefined behavior if not handled properly.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Syntax**: Always ensure that the syntax is correct, including all necessary parentheses and semicolons.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used correctly to allocate the right amount of memory.\n4. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n5. **Consider Using `new` and `delete`**: In C++, prefer using `new` and `delete` for memory management, as they are type-safe and integrate better with C++ features.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    // Corrected malloc usage with error checking\n    float* ptr = (float*)malloc(sizeof(float));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14f;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-86db3e7d-a3f9-4c12-b916-b1f1c9d289bb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc( sizeof( float )` is missing a closing parenthesis, which can cause a compilation error. Even if corrected, improper use of `malloc` can lead to memory leaks, buffer overflows, or undefined behavior if not handled properly.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Syntax**: Always ensure that the syntax is correct, including all necessary parentheses and semicolons.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used correctly to allocate the right amount of memory.\n4. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n5. **Consider Using `new` and `delete`**: In C++, prefer using `new` and `delete` for memory management, as they are type-safe and integrate better with C++ features.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    // Corrected malloc usage with error checking\n    float* ptr = (float*)malloc(sizeof(float));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14f;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-5a577a43-37bf-47d4-8f26-e63277f72b92",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, the vulnerability occurs when the size of the memory allocation is incorrectly calculated or insufficient for the intended use. In the example `malloc(sizeof(int32_t))`, the issue may arise if the allocated memory is intended to store more than one `int32_t` value, but only enough memory for a single `int32_t` is allocated. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Correct Memory Allocation**: Ensure that the size passed to `malloc` is sufficient for the intended use. If allocating memory for an array, multiply the size of the data type by the number of elements.\n2. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calculates the size.\n3. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Memory**: Use functions like `calloc` or explicitly initialize memory to avoid using uninitialized memory.\n5. **Free Memory**: Ensure that all allocated memory is properly freed to avoid memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <cstdint> // Required for int32_t\n\nint main() {\n    size_t num_elements = 10; // Example number of elements\n    int32_t* array = (int32_t*)malloc(num_elements * sizeof(int32_t));\n    \n    if (array == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize memory or use it as needed\n    for (size_t i = 0; i < num_elements; ++i) {\n        array[i] = 0; // Example initialization\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstdint>`: Required for `int32_t`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-dbca66e0-7a78-4030-8c41-079804bdd937",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, the vulnerability occurs when the size of the memory allocation is incorrectly calculated or insufficient for the intended use. In the example `malloc(sizeof(int32_t))`, the issue may arise if the allocated memory is intended to store more than one `int32_t` value, but only enough memory for a single `int32_t` is allocated. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Correct Memory Allocation**: Ensure that the size passed to `malloc` is sufficient for the intended use. If allocating memory for an array, multiply the size of the data type by the number of elements.\n2. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calculates the size.\n3. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Memory**: Use functions like `calloc` or explicitly initialize memory to avoid using uninitialized memory.\n5. **Free Memory**: Ensure that all allocated memory is properly freed to avoid memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <cstdint> // Required for int32_t\n\nint main() {\n    size_t num_elements = 10; // Example number of elements\n    int32_t* array = (int32_t*)malloc(num_elements * sizeof(int32_t));\n    \n    if (array == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize memory or use it as needed\n    for (size_t i = 0; i < num_elements; ++i) {\n        array[i] = 0; // Example initialization\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstdint>`: Required for `int32_t`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-73e384bc-3297-4582-9ff0-786b2a0937c2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc( sizeof( float )` is missing a closing parenthesis, which can cause a compilation error. Even if corrected, improper use of `malloc` can lead to memory leaks, buffer overflows, or undefined behavior if not handled properly.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Syntax**: Always ensure that the syntax is correct, including all necessary parentheses and semicolons.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used correctly to allocate the right amount of memory.\n4. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n5. **Consider Using `new` and `delete`**: In C++, prefer using `new` and `delete` for memory management, as they are type-safe and integrate better with C++ features.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    // Corrected malloc usage with error checking\n    float* ptr = (float*)malloc(sizeof(float));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14f;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-342b53fc-1221-4473-9e1d-0a5c0dee539a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, the vulnerability occurs when the size of the memory allocation is incorrectly calculated or insufficient for the intended use. In the example `malloc(sizeof(int32_t))`, the issue may arise if the allocated memory is intended to store more than one `int32_t` value, but only enough memory for a single `int32_t` is allocated. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Correct Memory Allocation**: Ensure that the size passed to `malloc` is sufficient for the intended use. If allocating memory for an array, multiply the size of the data type by the number of elements.\n2. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calculates the size.\n3. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Memory**: Use functions like `calloc` or explicitly initialize memory to avoid using uninitialized memory.\n5. **Free Memory**: Ensure that all allocated memory is properly freed to avoid memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <cstdint> // Required for int32_t\n\nint main() {\n    size_t num_elements = 10; // Example number of elements\n    int32_t* array = (int32_t*)malloc(num_elements * sizeof(int32_t));\n    \n    if (array == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize memory or use it as needed\n    for (size_t i = 0; i < num_elements; ++i) {\n        array[i] = 0; // Example initialization\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstdint>`: Required for `int32_t`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1a022724-3a2d-43b2-ab37-c2b73b96e6f1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc( sizeof( float )` is missing a closing parenthesis, which can cause a compilation error. Even if corrected, improper use of `malloc` can lead to memory leaks, buffer overflows, or undefined behavior if not handled properly.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Syntax**: Always ensure that the syntax is correct, including all necessary parentheses and semicolons.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used correctly to allocate the right amount of memory.\n4. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n5. **Consider Using `new` and `delete`**: In C++, prefer using `new` and `delete` for memory management, as they are type-safe and integrate better with C++ features.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    // Corrected malloc usage with error checking\n    float* ptr = (float*)malloc(sizeof(float));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14f;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-4c5766e9-82f9-4cbe-b7ef-ceadf725928d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, the vulnerability occurs when the size of the memory allocation is incorrectly calculated or insufficient for the intended use. In the example `malloc(sizeof(int32_t))`, the issue may arise if the allocated memory is intended to store more than one `int32_t` value, but only enough memory for a single `int32_t` is allocated. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Correct Memory Allocation**: Ensure that the size passed to `malloc` is sufficient for the intended use. If allocating memory for an array, multiply the size of the data type by the number of elements.\n2. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calculates the size.\n3. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Memory**: Use functions like `calloc` or explicitly initialize memory to avoid using uninitialized memory.\n5. **Free Memory**: Ensure that all allocated memory is properly freed to avoid memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <cstdint> // Required for int32_t\n\nint main() {\n    size_t num_elements = 10; // Example number of elements\n    int32_t* array = (int32_t*)malloc(num_elements * sizeof(int32_t));\n    \n    if (array == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize memory or use it as needed\n    for (size_t i = 0; i < num_elements; ++i) {\n        array[i] = 0; // Example initialization\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstdint>`: Required for `int32_t`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1c77e309-c0ce-4e06-b31a-6631fd4d20da",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, the vulnerability is related to the allocation of memory using `malloc` without proper checks or considerations for the size and type of the elements being allocated.\n\n### General Mitigation Advice\n\n1. **Validate Input**: Ensure that the input values used in memory allocation are validated to prevent excessive or negative allocations.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use Safer Alternatives**: Consider using `new` in C++ or safer memory management libraries that provide automatic memory management.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use `sizeof` Correctly**: Ensure that `sizeof` is used correctly to calculate the size of the data type being allocated.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // for malloc and free\n\n// Assuming aocl_post_op_eltwise is a defined struct or class\nstruct aocl_post_op_eltwise {\n    // member variables\n};\n\nint main() {\n    size_t num_eltwise = 10; // Example value, should be validated\n    aocl_post_op_eltwise* eltwise_array = static_cast<aocl_post_op_eltwise*>(\n        malloc(num_eltwise * sizeof(aocl_post_op_eltwise))\n    );\n\n    if (eltwise_array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(eltwise_array);\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-cb0a4039-af64-49bc-b507-33cc3e561027",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. Specifically, the vulnerability occurs when the `malloc` function is used without proper checks or calculations, which can result in insufficient memory allocation or incorrect memory usage.\n\nIn the provided code snippet, the expression `malloc(n * sizeof(BIAS_type))` is used to allocate memory. If `n` is not properly validated or if `sizeof(BIAS_type)` is incorrect, this can lead to memory allocation issues.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the value of `n` is validated to prevent integer overflow or underflow.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `calloc` for zero-initialized memory or smart pointers in C++ for automatic memory management.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cerr\n\ntypedef int BIAS_type; // Example type definition\n\nvoid allocateMemory(size_t n) {\n    // Validate input\n    if (n == 0 || n > SIZE_MAX / sizeof(BIAS_type)) {\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return;\n    }\n\n    // Allocate memory\n    BIAS_type* biasArray = static_cast<BIAS_type*>(malloc(n * sizeof(BIAS_type)));\n    \n    // Check if malloc succeeded\n    if (biasArray == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(biasArray);\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-3174a78a-27c3-4d74-b097-5bc89387c672",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, `malloc( n * sizeof( int32_t )`, the vulnerability may occur if the value of `n` is not properly validated, leading to an incorrect or excessive amount of memory being allocated. This can result in security vulnerabilities such as buffer overflows or denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the value of `n` is validated before being used in the `malloc` function. This includes checking for negative values, excessively large values, or any other invalid input that could lead to improper memory allocation.\n\n2. **Use Safer Alternatives**: Consider using safer memory allocation functions such as `calloc`, which initializes the allocated memory to zero, or C++ alternatives like `new` or `std::vector` that provide automatic memory management.\n\n3. **Check for Allocation Failure**: Always check the return value of `malloc` to ensure that memory allocation was successful before using the allocated memory.\n\n4. **Free Allocated Memory**: Ensure that any memory allocated with `malloc` is properly freed using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size, should be validated\n    if (n > SIZE_MAX / sizeof(int32_t)) {\n        std::cerr << \"Requested size is too large.\" << std::endl;\n        return 1;\n    }\n\n    int32_t* array = static_cast<int32_t*>(malloc(n * sizeof(int32_t)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<int32_t>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstdlib>`: Required for `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-72d833f0-ace9-455d-9530-0d830370da1d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, `malloc( n * sizeof( int8_t )`, the vulnerability may occur if `n` is not properly validated, leading to incorrect memory allocation size calculations. This can result in insufficient memory being allocated, which can cause buffer overflows or other memory-related issues.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the value of `n` is validated to be a positive integer and within a reasonable range before using it in the `malloc` function.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `calloc` for zero-initialized memory allocation or C++ alternatives like `new` or `std::vector` for automatic memory management.\n4. **Free Allocated Memory**: Ensure that any allocated memory is properly freed when no longer needed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <cstdint>  // Required for int8_t\n#include <iostream> // Required for std::cerr\n\nint main() {\n    size_t n = 10; // Example size, should be validated\n    if (n <= 0) {\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return 1;\n    }\n\n    int8_t* ptr = static_cast<int8_t*>(malloc(n * sizeof(int8_t)));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    free(ptr); // Free the allocated memory\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstdint>`: Required for `int8_t`.\n- `<iostream>`: Required for `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-10c32db0-5790-40f8-9b7f-200beb2077eb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used improperly, leading to potential memory allocation issues. In the provided code snippet, `malloc( n * sizeof( float )`, there is a missing closing parenthesis, which can cause a compilation error. However, even if the syntax is corrected, improper use of `malloc` can lead to vulnerabilities such as buffer overflows, memory leaks, or undefined behavior if not handled correctly.\n\n### General Mitigation Advice\n\n1. **Proper Syntax**: Ensure that all parentheses are correctly placed and balanced.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct data type.\n4. **Free Allocated Memory**: Always free the allocated memory using `free()` to prevent memory leaks.\n5. **Use Safer Alternatives**: Consider using C++ alternatives like `new` or containers like `std::vector` which handle memory management automatically.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float)); // Corrected malloc usage\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Example usage of the allocated array\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input/output operations.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [Common Weakness Enumeration (CWE-401: Missing Release of Memory after Effective Lifetime)](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-e4c00b75-f680-40a6-81a0-bca108a1523f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the provided code snippet, `malloc( n * sizeof( bfloat16 )`, the vulnerability may occur due to several reasons, such as:\n\n1. **Integer Overflow**: If `n` is a large value, multiplying it by `sizeof(bfloat16)` could result in an integer overflow, leading to insufficient memory allocation.\n2. **Unchecked Return Value**: If `malloc` fails, it returns `NULL`. If this return value is not checked, it can lead to dereferencing a null pointer, causing undefined behavior or a crash.\n3. **Improper Memory Management**: Failing to free the allocated memory can lead to memory leaks.\n\n### General Mitigation Advice\n\n- **Check for Integer Overflow**: Before calling `malloc`, ensure that the multiplication does not overflow.\n- **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n- **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed when no longer needed.\n- **Use Safer Alternatives**: Consider using `calloc`, which initializes the allocated memory to zero, or higher-level abstractions like `std::vector` in C++.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\ntypedef float bfloat16; // Assuming bfloat16 is a float for this example\n\nbfloat16* allocateMemory(size_t n) {\n    // Check for potential overflow\n    if (n > std::numeric_limits<size_t>::max() / sizeof(bfloat16)) {\n        std::cerr << \"Size overflow detected!\" << std::endl;\n        return nullptr;\n    }\n\n    bfloat16* ptr = static_cast<bfloat16*>(malloc(n * sizeof(bfloat16)));\n    if (!ptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return nullptr;\n    }\n\n    return ptr;\n}\n\nint main() {\n    size_t n = 100; // Example size\n    bfloat16* data = allocateMemory(n);\n    if (data) {\n        // Use the allocated memory\n        // ...\n\n        // Free the allocated memory\n        free(data);\n    }\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To use `std::numeric_limits`.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-14c918b0-8ab0-4f74-87bb-da4397aa2eb7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(sizeof(aocl_post_op_bias))`, the vulnerability may occur if `aocl_post_op_bias` is a pointer or an incomplete type, leading to incorrect memory allocation size.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used on the correct type or object. If `aocl_post_op_bias` is a pointer, use `sizeof(*aocl_post_op_bias)` to allocate memory for the object it points to.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use Smart Pointers**: In C++, prefer using smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage dynamic memory automatically.\n4. **Initialize Memory**: Consider using `calloc` instead of `malloc` if you need the allocated memory to be initialized to zero.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for malloc, free\n#include <iostream> // for std::cerr\n\n// Assuming aocl_post_op_bias is a struct or class\nstruct aocl_post_op_bias {\n    // members of the struct\n};\n\nint main() {\n    // Correct usage of sizeof\n    aocl_post_op_bias* bias = (aocl_post_op_bias*)malloc(sizeof(aocl_post_op_bias));\n    \n    if (bias == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(bias);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for `std::cerr` to output error messages.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-b0718ade-5d93-47fc-8740-e85daaf74571",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "blastest/f2c/open.c"
                },
                "region": {
                  "startLine": 258,
                  "startColumn": 11,
                  "endLine": 258,
                  "endColumn": 23,
                  "charOffset": 6064,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(nbuf)",
                    "rendered": {
                      "text": "strlen(nbuf)",
                      "markdown": "`strlen(nbuf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6064,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(nbuf, <size of nbuf>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6064,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(nbuf, <size of nbuf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-42086b2a-63bf-4d99-ac4c-4bac9c70099f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "blastest/f2c/open.c"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 8,
                  "endLine": 218,
                  "endColumn": 27,
                  "charOffset": 4958,
                  "charLength": 19,
                  "snippet": {
                    "text": "strcpy(b->ufnm,buf)",
                    "rendered": {
                      "text": "strcpy(b->ufnm,buf)",
                      "markdown": "`strcpy(b->ufnm,buf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4958,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strcpy_s(b->ufnm, <size of b->ufnm>, buf)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4958,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strlcpy(b->ufnm, buf, <size of b->ufnm>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2ced5f1c-5172-45c3-a442-d20817ca2b06",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "blastest/f2c/open.c"
                },
                "region": {
                  "startLine": 216,
                  "startColumn": 40,
                  "endLine": 216,
                  "endColumn": 51,
                  "charOffset": 4882,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(buf)",
                    "rendered": {
                      "text": "strlen(buf)",
                      "markdown": "`strlen(buf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4882,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(buf, <size of buf>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4882,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(buf, <size of buf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8af54ca6-078c-4e5b-af76-6e86deee09f3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "blastest/f2c/open.c"
                },
                "region": {
                  "startLine": 216,
                  "startColumn": 18,
                  "endLine": 216,
                  "endColumn": 39,
                  "charOffset": 4860,
                  "charLength": 21,
                  "snippet": {
                    "text": "malloc((unsigned int)",
                    "rendered": {
                      "text": "malloc((unsigned int)",
                      "markdown": "`malloc((unsigned int)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4860,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2ba8b737-0aae-4681-ab0d-dcb4cd56e5fc",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "blastest/f2c/open.c"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 9,
                  "endLine": 197,
                  "endColumn": 34,
                  "charOffset": 4531,
                  "charLength": 25,
                  "snippet": {
                    "text": "strcpy(buf,\"tmp.FXXXXXX\")",
                    "rendered": {
                      "text": "strcpy(buf,\"tmp.FXXXXXX\")",
                      "markdown": "`strcpy(buf,\"tmp.FXXXXXX\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4531,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strcpy_s(buf, <size of buf>, \"tmp.FXXXXXX\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4531,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strlcpy(buf, \"tmp.FXXXXXX\", <size of buf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cbb4f143-a35c-4362-aab1-597e18908956",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "blastest/f2c/open.c"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 6,
                  "endLine": 138,
                  "endColumn": 21,
                  "charOffset": 3338,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(b->ufnm)",
                    "rendered": {
                      "text": "strlen(b->ufnm)",
                      "markdown": "`strlen(b->ufnm)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3338,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(b->ufnm, <size of b->ufnm>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3338,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(b->ufnm, <size of b->ufnm>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-187064f1-70ca-4409-a28f-0f13a110a0df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "blastest/f2c/open.c"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 7,
                  "endLine": 85,
                  "endColumn": 16,
                  "charOffset": 2323,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(s)",
                    "rendered": {
                      "text": "strlen(s)",
                      "markdown": "`strlen(s)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2323,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(s, <size of s>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2323,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(s, <size of s>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef62f111-4183-476a-967b-638bf8d2daa0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_30x8_knc.c"
                },
                "region": {
                  "startLine": 413,
                  "startColumn": 19,
                  "endLine": 413,
                  "endColumn": 22,
                  "charOffset": 14432,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-9dd98a2d-0f1f-4de9-89ae-fe8ffcf8294d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_30x8_knc.c"
                },
                "region": {
                  "startLine": 287,
                  "startColumn": 20,
                  "endLine": 287,
                  "endColumn": 23,
                  "charOffset": 11064,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-55f27f92-a709-42ab-94d4-2875e7618116",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_30x8_knc.c"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 19,
                  "endLine": 231,
                  "endColumn": 22,
                  "charOffset": 9969,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-1eef0c61-2d98-4a7c-aecb-bd24a75f18a0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_30x8_knc.c"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 19,
                  "endLine": 193,
                  "endColumn": 22,
                  "charOffset": 8281,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d1ca20f0-b116-461c-b491-5799cb528b5f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "blastest/f2c/open.c"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 41,
                  "endLine": 53,
                  "endColumn": 52,
                  "charOffset": 1851,
                  "charLength": 11,
                  "snippet": {
                    "text": "malloc(len)",
                    "rendered": {
                      "text": "malloc(len)",
                      "markdown": "`malloc(len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "blastest/f2c/open.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1851,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ad54d3ef-71d6-4239-b364-48ba2d6a9319",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_sgemm_knl_asm_30x16_knc.c"
                },
                "region": {
                  "startLine": 422,
                  "startColumn": 19,
                  "endLine": 422,
                  "endColumn": 22,
                  "charOffset": 14885,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d808d4ff-c1c7-49c6-8a68-8ca30e1a6f07",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_sgemm_knl_asm_30x16_knc.c"
                },
                "region": {
                  "startLine": 296,
                  "startColumn": 20,
                  "endLine": 296,
                  "endColumn": 23,
                  "charOffset": 11514,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-af24422e-01f2-46e0-859c-e8e389ac8cda",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_sgemm_knl_asm_30x16_knc.c"
                },
                "region": {
                  "startLine": 240,
                  "startColumn": 19,
                  "endLine": 240,
                  "endColumn": 22,
                  "charOffset": 10419,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-75edd684-4800-44de-b89b-26c78a0ce45a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_sgemm_knl_asm_30x16_knc.c"
                },
                "region": {
                  "startLine": 202,
                  "startColumn": 19,
                  "endLine": 202,
                  "endColumn": 22,
                  "charOffset": 8729,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-6cb67e92-3956-44ac-a0c9-22815d625e43",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_8x24.c"
                },
                "region": {
                  "startLine": 725,
                  "startColumn": 19,
                  "endLine": 725,
                  "endColumn": 22,
                  "charOffset": 20543,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-673ee2ee-57f8-45a8-bc28-54ee51dc1fc2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_8x24.c"
                },
                "region": {
                  "startLine": 485,
                  "startColumn": 19,
                  "endLine": 485,
                  "endColumn": 22,
                  "charOffset": 13556,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-3aa3d908-ffa2-40ec-b4ae-96e3bb6671c6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/lpgemm/f32f32f32/lpgemm_pack_a_f32_amd512vnni.c"
                },
                "region": {
                  "startLine": 958,
                  "startColumn": 3,
                  "endLine": 962,
                  "endColumn": 45,
                  "charOffset": 47822,
                  "charLength": 147,
                  "snippet": {
                    "text": "memcpy\n\t\t\t(\n\t\t\t  pack_a_buf + ( ic * KC ) + ( kr_full_pieces_loop_limit * MR ),\n\t\t\t  temp_pack_a_buf,\n\t\t\t  kr_partial_pieces * MR * sizeof( float )",
                    "rendered": {
                      "text": "memcpy\n\t\t\t(\n\t\t\t  pack_a_buf + ( ic * KC ) + ( kr_full_pieces_loop_limit * MR ),\n\t\t\t  temp_pack_a_buf,\n\t\t\t  kr_partial_pieces * MR * sizeof( float )",
                      "markdown": "`memcpy\n\t\t\t(\n\t\t\t  pack_a_buf + ( ic * KC ) + ( kr_full_pieces_loop_limit * MR ),\n\t\t\t  temp_pack_a_buf,\n\t\t\t  kr_partial_pieces * MR * sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "kernels/zen4/lpgemm/f32f32f32/lpgemm_pack_a_f32_amd512vnni.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47822,
                        "charLength": 147
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n\t\t\t  pack_a_buf + ( ic * KC ) + ( kr_full_pieces_loop_limit * MR ), <size of \n\t\t\t  pack_a_buf + ( ic * KC ) + ( kr_full_pieces_loop_limit * MR )>, \n\t\t\t  temp_pack_a_buf, \n\t\t\t  kr_partial_pieces * MR * sizeof( float )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1518e37b-0602-4f77-b561-ac49fdc3254f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 829,
                  "startColumn": 16,
                  "endLine": 829,
                  "endColumn": 76,
                  "charOffset": 29394,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29394,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29394,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5ba4551f-aa01-41a9-bc5f-3315d220d670",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 816,
                  "startColumn": 16,
                  "endLine": 816,
                  "endColumn": 76,
                  "charOffset": 28812,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28812,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28812,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bbf03d4a-c79a-4465-ba5f-f9b4794e4f22",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 806,
                  "startColumn": 16,
                  "endLine": 806,
                  "endColumn": 69,
                  "charOffset": 28383,
                  "charLength": 53,
                  "snippet": {
                    "text": "strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )",
                    "rendered": {
                      "text": "strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )",
                      "markdown": "`strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28383,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str,  POST_OPS_STR_LEN - 1 ,  \"none\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28383,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str,  \"none\",  POST_OPS_STR_LEN - 1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-110cdf2a-d8ee-4a5a-85b3-d497a49a6af9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 802,
                  "startColumn": 16,
                  "endLine": 802,
                  "endColumn": 70,
                  "charOffset": 28266,
                  "charLength": 54,
                  "snippet": {
                    "text": "strncpy( post_ops_str, ops_tok, POST_OPS_STR_LEN - 1 )",
                    "rendered": {
                      "text": "strncpy( post_ops_str, ops_tok, POST_OPS_STR_LEN - 1 )",
                      "markdown": "`strncpy( post_ops_str, ops_tok, POST_OPS_STR_LEN - 1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28266,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str,  POST_OPS_STR_LEN - 1 ,  ops_tok)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28266,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str,  ops_tok,  POST_OPS_STR_LEN - 1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c21e67a6-fa35-466c-b94b-a33a4137f424",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 796,
                  "startColumn": 12,
                  "endLine": 796,
                  "endColumn": 68,
                  "charOffset": 28056,
                  "charLength": 56,
                  "snippet": {
                    "text": "strncpy( gemm_type_str, ops_tok, GEMM_TYPE_STR_LEN - 1 )",
                    "rendered": {
                      "text": "strncpy( gemm_type_str, ops_tok, GEMM_TYPE_STR_LEN - 1 )",
                      "markdown": "`strncpy( gemm_type_str, ops_tok, GEMM_TYPE_STR_LEN - 1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28056,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "strcpy_s( gemm_type_str,  GEMM_TYPE_STR_LEN - 1 ,  ops_tok)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28056,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "strlcpy( gemm_type_str,  ops_tok,  GEMM_TYPE_STR_LEN - 1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e1cdee8a-509c-4dec-b328-6969f81f5ad7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 539,
                  "startColumn": 8,
                  "endLine": 539,
                  "endColumn": 50,
                  "charOffset": 19532,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(c_ref, c , (size_C * sizeof(C_type)",
                    "rendered": {
                      "text": "memcpy(c_ref, c , (size_C * sizeof(C_type)",
                      "markdown": "`memcpy(c_ref, c , (size_C * sizeof(C_type)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19532,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c_ref, <size of c_ref>,  c ,  (size_C * sizeof(C_type)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9d53397f-00de-40b6-80d9-604197a9583c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 505,
                  "startColumn": 4,
                  "endLine": 505,
                  "endColumn": 66,
                  "charOffset": 18147,
                  "charLength": 62,
                  "snippet": {
                    "text": "strncpy( post_ops_str_copy, post_ops_str, POST_OPS_STR_LEN-1 )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_copy, post_ops_str, POST_OPS_STR_LEN-1 )",
                      "markdown": "`strncpy( post_ops_str_copy, post_ops_str, POST_OPS_STR_LEN-1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18147,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_copy,  POST_OPS_STR_LEN-1 ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18147,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_copy,  post_ops_str,  POST_OPS_STR_LEN-1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d954b7a4-c952-4a01-82b9-4382ba5a2690",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 40,
                  "endLine": 69,
                  "endColumn": 48,
                  "charOffset": 2667,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-42edb526-f5cd-47dd-9f47-17970c798182",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/include/bli_x86_asm_macros.h"
                },
                "region": {
                  "startLine": 250,
                  "startColumn": 12,
                  "endLine": 250,
                  "endColumn": 15,
                  "charOffset": 6885,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-7173ae80-44d8-420a-82a3-188265dc8f03",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/include/bli_x86_asm_macros.h"
                },
                "region": {
                  "startLine": 233,
                  "startColumn": 8,
                  "endLine": 233,
                  "endColumn": 11,
                  "charOffset": 6436,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-c7b8d0ef-1e71-40de-a876-7eebec2640fa",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 40,
                  "endLine": 69,
                  "endColumn": 45,
                  "charOffset": 2667,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-3cc38cab-d736-47b5-a358-371676671f45",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 35,
                  "endLine": 54,
                  "endColumn": 43,
                  "charOffset": 2126,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-ac6b7bab-dcda-4991-a395-e1cec1233da0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_sym_quant.c"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 35,
                  "endLine": 54,
                  "endColumn": 40,
                  "charOffset": 2126,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b36031d0-c2c7-424d-b5ea-8550863e5262",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1334,
                  "startColumn": 16,
                  "endLine": 1334,
                  "endColumn": 76,
                  "charOffset": 52553,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52553,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52553,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-04f04a8c-ab32-4b1c-80ac-89e7993215be",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1319,
                  "startColumn": 16,
                  "endLine": 1319,
                  "endColumn": 76,
                  "charOffset": 51895,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51895,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51895,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b7adef19-d6c1-40d9-af40-0adc50c17696",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1304,
                  "startColumn": 16,
                  "endLine": 1304,
                  "endColumn": 76,
                  "charOffset": 51247,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51247,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51247,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f1f736fb-3c39-46a2-8843-892aae6bd6ed",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1289,
                  "startColumn": 16,
                  "endLine": 1289,
                  "endColumn": 76,
                  "charOffset": 50598,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 50598,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 50598,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6d3095fd-6d2f-4079-8173-ef2f4eee3197",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1274,
                  "startColumn": 16,
                  "endLine": 1274,
                  "endColumn": 76,
                  "charOffset": 49942,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49942,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49942,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1af2b1d8-d775-4c8f-8eea-80339a1d7b2d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1252,
                  "startColumn": 16,
                  "endLine": 1252,
                  "endColumn": 76,
                  "charOffset": 49059,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49059,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49059,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6b1d0304-0af5-47b7-bbf0-d1df4cec1053",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1231,
                  "startColumn": 16,
                  "endLine": 1231,
                  "endColumn": 76,
                  "charOffset": 48236,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48236,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48236,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1c3811e4-a1c2-49cb-9d64-f482c3f2e351",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1219,
                  "startColumn": 16,
                  "endLine": 1219,
                  "endColumn": 76,
                  "charOffset": 47713,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47713,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47713,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2816319a-c5af-41c5-998f-16644783802c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1206,
                  "startColumn": 16,
                  "endLine": 1206,
                  "endColumn": 76,
                  "charOffset": 47121,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47121,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47121,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0cd0ffdd-7dc2-43ec-807f-c0fa44c6bc43",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1192,
                  "startColumn": 16,
                  "endLine": 1192,
                  "endColumn": 76,
                  "charOffset": 46503,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46503,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46503,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d2c327dd-8f63-468a-9b42-c03535802fd6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1177,
                  "startColumn": 16,
                  "endLine": 1177,
                  "endColumn": 76,
                  "charOffset": 45843,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45843,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45843,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a112d9de-d41a-432e-b147-6d973c2ed6b8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1162,
                  "startColumn": 16,
                  "endLine": 1162,
                  "endColumn": 76,
                  "charOffset": 45185,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45185,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45185,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f5e88057-cfc4-4bfe-8729-76a048f72818",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1138,
                  "startColumn": 16,
                  "endLine": 1138,
                  "endColumn": 76,
                  "charOffset": 44226,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44226,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44226,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c67a6f5b-a3d3-4255-8c30-519e7ac1afc5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1120,
                  "startColumn": 16,
                  "endLine": 1120,
                  "endColumn": 76,
                  "charOffset": 43387,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43387,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43387,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b01d31bf-1161-458d-873d-c6b8b1bd9659",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1105,
                  "startColumn": 16,
                  "endLine": 1105,
                  "endColumn": 76,
                  "charOffset": 42731,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42731,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42731,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-af6242a1-1d37-45b3-b33b-eefa83199eba",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1087,
                  "startColumn": 16,
                  "endLine": 1087,
                  "endColumn": 76,
                  "charOffset": 41889,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41889,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41889,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-49f120a5-c148-4668-ac1b-8bb8a7e913e8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1077,
                  "startColumn": 16,
                  "endLine": 1077,
                  "endColumn": 69,
                  "charOffset": 41462,
                  "charLength": 53,
                  "snippet": {
                    "text": "strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )",
                    "rendered": {
                      "text": "strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )",
                      "markdown": "`strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41462,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str,  POST_OPS_STR_LEN - 1 ,  \"none\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41462,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str,  \"none\",  POST_OPS_STR_LEN - 1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-70b21abf-75f9-494c-b4d3-535b26ad45df",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 4289,
                  "startColumn": 10,
                  "endLine": 4289,
                  "endColumn": 13,
                  "charOffset": 134928,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d452ab80-3f17-4fc0-bfc0-3a998a6285a6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 4288,
                  "startColumn": 30,
                  "endLine": 4288,
                  "endColumn": 33,
                  "charOffset": 134913,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0c9c866a-4a15-4042-b139-b45651c30e53",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 4065,
                  "startColumn": 10,
                  "endLine": 4065,
                  "endColumn": 13,
                  "charOffset": 128643,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-1392d4e7-08b6-46ab-9b35-a3a5f69a876f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 3835,
                  "startColumn": 10,
                  "endLine": 3835,
                  "endColumn": 13,
                  "charOffset": 122249,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-64427caa-5c86-4901-ba1c-a4e0bb45a29d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 3834,
                  "startColumn": 30,
                  "endLine": 3834,
                  "endColumn": 33,
                  "charOffset": 122234,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-f4bb5cf8-7894-4e64-bde5-7c896f02b69f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 3374,
                  "startColumn": 10,
                  "endLine": 3374,
                  "endColumn": 13,
                  "charOffset": 109663,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0ba4424a-4544-4662-9d29-72aa5ec9248e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 3373,
                  "startColumn": 30,
                  "endLine": 3373,
                  "endColumn": 33,
                  "charOffset": 109648,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b0ff2396-540a-48f4-9159-871733471a17",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 3129,
                  "startColumn": 10,
                  "endLine": 3129,
                  "endColumn": 13,
                  "charOffset": 102766,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-70debcb7-95cc-41d4-ae96-f19ca1af837c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 2877,
                  "startColumn": 10,
                  "endLine": 2877,
                  "endColumn": 13,
                  "charOffset": 95685,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-4774873a-e371-40cb-a4eb-3adb70c3a51b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 2876,
                  "startColumn": 30,
                  "endLine": 2876,
                  "endColumn": 33,
                  "charOffset": 95670,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-70860644-3971-4ede-8389-02acbbe948d6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 2273,
                  "startColumn": 10,
                  "endLine": 2273,
                  "endColumn": 13,
                  "charOffset": 78534,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e95c82ef-24c3-41a7-9ed4-414631a06789",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 2272,
                  "startColumn": 30,
                  "endLine": 2272,
                  "endColumn": 33,
                  "charOffset": 78519,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-84af8758-cf9e-4a5c-82e7-105ca48d73cc",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 1869,
                  "startColumn": 10,
                  "endLine": 1869,
                  "endColumn": 13,
                  "charOffset": 66334,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-301d8861-0b11-4792-b127-cd695fe4e4ec",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 1868,
                  "startColumn": 30,
                  "endLine": 1868,
                  "endColumn": 33,
                  "charOffset": 66319,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-ceb7fc15-048c-4e6d-8822-a49e449088ac",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 1450,
                  "startColumn": 10,
                  "endLine": 1450,
                  "endColumn": 13,
                  "charOffset": 53606,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-9135bd81-ae92-49d3-ac44-70e41d2ecffa",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 1449,
                  "startColumn": 30,
                  "endLine": 1449,
                  "endColumn": 33,
                  "charOffset": 53591,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-f95aa7f3-26c1-408d-8546-debc4a6a7c97",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1073,
                  "startColumn": 16,
                  "endLine": 1073,
                  "endColumn": 70,
                  "charOffset": 41345,
                  "charLength": 54,
                  "snippet": {
                    "text": "strncpy( post_ops_str, ops_tok, POST_OPS_STR_LEN - 1 )",
                    "rendered": {
                      "text": "strncpy( post_ops_str, ops_tok, POST_OPS_STR_LEN - 1 )",
                      "markdown": "`strncpy( post_ops_str, ops_tok, POST_OPS_STR_LEN - 1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41345,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str,  POST_OPS_STR_LEN - 1 ,  ops_tok)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41345,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str,  ops_tok,  POST_OPS_STR_LEN - 1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4bceb6a3-70f0-4b70-b8f0-9b9b6f3852d9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1067,
                  "startColumn": 12,
                  "endLine": 1067,
                  "endColumn": 68,
                  "charOffset": 41135,
                  "charLength": 56,
                  "snippet": {
                    "text": "strncpy( gemm_type_str, ops_tok, GEMM_TYPE_STR_LEN - 1 )",
                    "rendered": {
                      "text": "strncpy( gemm_type_str, ops_tok, GEMM_TYPE_STR_LEN - 1 )",
                      "markdown": "`strncpy( gemm_type_str, ops_tok, GEMM_TYPE_STR_LEN - 1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41135,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "strcpy_s( gemm_type_str,  GEMM_TYPE_STR_LEN - 1 ,  ops_tok)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41135,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "strlcpy( gemm_type_str,  ops_tok,  GEMM_TYPE_STR_LEN - 1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5f00ee7b-09a0-4673-a120-8272ec840784",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 778,
                  "startColumn": 8,
                  "endLine": 778,
                  "endColumn": 50,
                  "charOffset": 30440,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(c_ref, c , (size_C * sizeof(C_type)",
                    "rendered": {
                      "text": "memcpy(c_ref, c , (size_C * sizeof(C_type)",
                      "markdown": "`memcpy(c_ref, c , (size_C * sizeof(C_type)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30440,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c_ref, <size of c_ref>,  c ,  (size_C * sizeof(C_type)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-44d23e0b-f6e0-40f7-ae10-7ec934e1d872",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 735,
                  "startColumn": 4,
                  "endLine": 735,
                  "endColumn": 66,
                  "charOffset": 28792,
                  "charLength": 62,
                  "snippet": {
                    "text": "strncpy( post_ops_str_copy, post_ops_str, POST_OPS_STR_LEN-1 )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_copy, post_ops_str, POST_OPS_STR_LEN-1 )",
                      "markdown": "`strncpy( post_ops_str_copy, post_ops_str, POST_OPS_STR_LEN-1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28792,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_copy,  POST_OPS_STR_LEN-1 ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28792,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_copy,  post_ops_str,  POST_OPS_STR_LEN-1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-38477e1e-73b2-47e9-9b59-a5425c69dc46",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 40,
                  "endLine": 69,
                  "endColumn": 48,
                  "charOffset": 2674,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-4ac09864-7ae5-455e-a1c1-3e9345175ecc",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 40,
                  "endLine": 69,
                  "endColumn": 45,
                  "charOffset": 2674,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-9239ca55-7d96-4843-bc56-d100904e57a1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 35,
                  "endLine": 54,
                  "endColumn": 43,
                  "charOffset": 2133,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-6be9c4b7-ca2a-4fda-9eb8-bda30bb18629",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 35,
                  "endLine": 54,
                  "endColumn": 40,
                  "charOffset": 2133,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-349272cb-5de0-426a-9092-83a2d26ddb4e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2470,
                  "startColumn": 57,
                  "endLine": 2470,
                  "endColumn": 94,
                  "charOffset": 86257,
                  "charLength": 37,
                  "snippet": {
                    "text": "malloc(n * num_groups * sizeof(float)",
                    "rendered": {
                      "text": "malloc(n * num_groups * sizeof(float)",
                      "markdown": "`malloc(n * num_groups * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 86257,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fe115bc8-3887-4120-9fc8-b23c7da7234a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2463,
                  "startColumn": 57,
                  "endLine": 2463,
                  "endColumn": 94,
                  "charOffset": 85716,
                  "charLength": 37,
                  "snippet": {
                    "text": "malloc(m * num_groups * sizeof(float)",
                    "rendered": {
                      "text": "malloc(m * num_groups * sizeof(float)",
                      "markdown": "`malloc(m * num_groups * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85716,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cbfe0761-a975-4354-850f-c09dc9c3e774",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2456,
                  "startColumn": 57,
                  "endLine": 2456,
                  "endColumn": 97,
                  "charOffset": 85291,
                  "charLength": 40,
                  "snippet": {
                    "text": "malloc(n * num_groups * sizeof(bfloat16)",
                    "rendered": {
                      "text": "malloc(n * num_groups * sizeof(bfloat16)",
                      "markdown": "`malloc(n * num_groups * sizeof(bfloat16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85291,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7f332897-f5d7-4120-b90c-b4739ebca626",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2452,
                  "startColumn": 57,
                  "endLine": 2452,
                  "endColumn": 97,
                  "charOffset": 84905,
                  "charLength": 40,
                  "snippet": {
                    "text": "malloc(m * num_groups * sizeof(bfloat16)",
                    "rendered": {
                      "text": "malloc(m * num_groups * sizeof(bfloat16)",
                      "markdown": "`malloc(m * num_groups * sizeof(bfloat16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 84905,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0c8bffd9-ce04-4e9f-8785-36515dd16f0a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2448,
                  "startColumn": 39,
                  "endLine": 2448,
                  "endColumn": 68,
                  "charOffset": 84670,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_pre_op_sf)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_pre_op_sf)",
                      "markdown": "`malloc(sizeof(aocl_pre_op_sf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 84670,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-787c8b36-066c-45c4-be50-4c36c9ab7bb9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2446,
                  "startColumn": 39,
                  "endLine": 2446,
                  "endColumn": 68,
                  "charOffset": 84522,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_pre_op_sf)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_pre_op_sf)",
                      "markdown": "`malloc(sizeof(aocl_pre_op_sf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 84522,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-26045042-3720-4e6b-af8f-f3cceee34eb0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2419,
                  "startColumn": 32,
                  "endLine": 2419,
                  "endColumn": 65,
                  "charOffset": 83344,
                  "charLength": 33,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_group_post_op)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_group_post_op)",
                      "markdown": "`malloc(sizeof(aocl_group_post_op)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 83344,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-65c2dff5-56ce-40ef-ba20-9fa3d2a5e3f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2406,
                  "startColumn": 61,
                  "endLine": 2406,
                  "endColumn": 119,
                  "charOffset": 82604,
                  "charLength": 58,
                  "snippet": {
                    "text": "malloc( num_groups * scale_factor_len * sizeof( bfloat16 )",
                    "rendered": {
                      "text": "malloc( num_groups * scale_factor_len * sizeof( bfloat16 )",
                      "markdown": "`malloc( num_groups * scale_factor_len * sizeof( bfloat16 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 82604,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-80a6266c-276f-4a2d-86e4-ff33f119ce5a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2399,
                  "startColumn": 61,
                  "endLine": 2399,
                  "endColumn": 116,
                  "charOffset": 82137,
                  "charLength": 55,
                  "snippet": {
                    "text": "malloc( num_groups * scale_factor_len * sizeof( float )",
                    "rendered": {
                      "text": "malloc( num_groups * scale_factor_len * sizeof( float )",
                      "markdown": "`malloc( num_groups * scale_factor_len * sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 82137,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-47bd0729-1672-4541-b7d0-7a4e386ebe4c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2393,
                  "startColumn": 39,
                  "endLine": 2393,
                  "endColumn": 71,
                  "charOffset": 81756,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_pre_op_sf )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_pre_op_sf )",
                      "markdown": "`malloc( sizeof( aocl_pre_op_sf )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 81756,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-019a6c69-c4dd-4bce-abbc-02bcb17d9e0a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2384,
                  "startColumn": 58,
                  "endLine": 2384,
                  "endColumn": 111,
                  "charOffset": 81256,
                  "charLength": 53,
                  "snippet": {
                    "text": "malloc( num_groups * zp_vec_length * sizeof( int8_t )",
                    "rendered": {
                      "text": "malloc( num_groups * zp_vec_length * sizeof( int8_t )",
                      "markdown": "`malloc( num_groups * zp_vec_length * sizeof( int8_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 81256,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e78ba5c0-f756-4678-abcb-45ffe5f20b37",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2382,
                  "startColumn": 42,
                  "endLine": 2382,
                  "endColumn": 74,
                  "charOffset": 81081,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_pre_op_zp )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_pre_op_zp )",
                      "markdown": "`malloc( sizeof( aocl_pre_op_zp )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 81081,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-161ad327-7531-411d-b24b-27205ff4ef7c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2358,
                  "startColumn": 28,
                  "endLine": 2358,
                  "endColumn": 57,
                  "charOffset": 80333,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_pre_op )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_pre_op )",
                      "markdown": "`malloc( sizeof( aocl_pre_op )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80333,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bb793964-5c80-412a-8485-64ff30c02df1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2338,
                  "startColumn": 49,
                  "endLine": 2338,
                  "endColumn": 88,
                  "charOffset": 79599,
                  "charLength": 39,
                  "snippet": {
                    "text": "malloc( n_scale * sizeof( DSCALE_type )",
                    "rendered": {
                      "text": "malloc( n_scale * sizeof( DSCALE_type )",
                      "markdown": "`malloc( n_scale * sizeof( DSCALE_type )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 79599,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-93e35cb0-7111-4e5a-9733-38d74e0a8d72",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2318,
                  "startColumn": 55,
                  "endLine": 2318,
                  "endColumn": 84,
                  "charOffset": 78866,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(float)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(float)",
                      "markdown": "`malloc( m * n * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 78866,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-198bb2c5-9601-495f-83a8-cbaaf4f64429",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2308,
                  "startColumn": 55,
                  "endLine": 2308,
                  "endColumn": 92,
                  "charOffset": 78362,
                  "charLength": 37,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(C_DSCALE_type)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(C_DSCALE_type)",
                      "markdown": "`malloc( m * n * sizeof(C_DSCALE_type)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 78362,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9b61ec4a-b913-4cab-b6d2-a0295a9f7e27",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2295,
                  "startColumn": 55,
                  "endLine": 2295,
                  "endColumn": 86,
                  "charOffset": 77793,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int32_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int32_t)",
                      "markdown": "`malloc( m * n * sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 77793,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9f3c0d8b-5886-417c-a021-f3fad4329a56",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2285,
                  "startColumn": 55,
                  "endLine": 2285,
                  "endColumn": 85,
                  "charOffset": 77303,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int8_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int8_t)",
                      "markdown": "`malloc( m * n * sizeof(int8_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 77303,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9984e0c8-987c-4ed2-b5ab-239f79e80827",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2268,
                  "startColumn": 51,
                  "endLine": 2268,
                  "endColumn": 81,
                  "charOffset": 76599,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int8_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int8_t)",
                      "markdown": "`malloc( m * n * sizeof(int8_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 76599,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-45436562-34cd-4057-816b-3dd8f0a8f413",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2258,
                  "startColumn": 51,
                  "endLine": 2258,
                  "endColumn": 82,
                  "charOffset": 76093,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int32_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int32_t)",
                      "markdown": "`malloc( m * n * sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 76093,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-14564e97-1f09-4e1a-aa95-861b9cefc07c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2248,
                  "startColumn": 51,
                  "endLine": 2248,
                  "endColumn": 80,
                  "charOffset": 75589,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(float)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(float)",
                      "markdown": "`malloc( m * n * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75589,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f2d80fd4-bec0-43d9-a1aa-a51826cc41e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2238,
                  "startColumn": 51,
                  "endLine": 2238,
                  "endColumn": 83,
                  "charOffset": 75081,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(bfloat16)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(bfloat16)",
                      "markdown": "`malloc( m * n * sizeof(bfloat16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75081,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b989a44a-3101-4efa-b82e-f92c583d205f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2228,
                  "startColumn": 31,
                  "endLine": 2228,
                  "endColumn": 72,
                  "charOffset": 74674,
                  "charLength": 41,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_post_op_matrix_mul )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_post_op_matrix_mul )",
                      "markdown": "`malloc( sizeof( aocl_post_op_matrix_mul )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 74674,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bc7d0891-2757-46fc-9f94-49a2df66b046",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2210,
                  "startColumn": 49,
                  "endLine": 2210,
                  "endColumn": 88,
                  "charOffset": 73976,
                  "charLength": 39,
                  "snippet": {
                    "text": "malloc( n_scale * sizeof( DSCALE_type )",
                    "rendered": {
                      "text": "malloc( n_scale * sizeof( DSCALE_type )",
                      "markdown": "`malloc( n_scale * sizeof( DSCALE_type )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73976,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-470ac4c8-90f4-47ec-93c9-58ed685b1d00",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2190,
                  "startColumn": 55,
                  "endLine": 2190,
                  "endColumn": 84,
                  "charOffset": 73243,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(float)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(float)",
                      "markdown": "`malloc( m * n * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73243,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8fcf436b-ee3e-4dfc-950f-d3a1ab6a4ebd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2180,
                  "startColumn": 55,
                  "endLine": 2180,
                  "endColumn": 92,
                  "charOffset": 72739,
                  "charLength": 37,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(C_DSCALE_type)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(C_DSCALE_type)",
                      "markdown": "`malloc( m * n * sizeof(C_DSCALE_type)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 72739,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-373633a5-e19d-456f-b089-a81f4678c1d2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2167,
                  "startColumn": 55,
                  "endLine": 2167,
                  "endColumn": 86,
                  "charOffset": 72170,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int32_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int32_t)",
                      "markdown": "`malloc( m * n * sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 72170,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e9151b79-6d5e-4aaf-ae1e-5eb46b6df627",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2157,
                  "startColumn": 55,
                  "endLine": 2157,
                  "endColumn": 85,
                  "charOffset": 71680,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int8_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int8_t)",
                      "markdown": "`malloc( m * n * sizeof(int8_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 71680,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-66682820-3120-40c0-958b-8dbf790faceb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2140,
                  "startColumn": 51,
                  "endLine": 2140,
                  "endColumn": 81,
                  "charOffset": 70976,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int8_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int8_t)",
                      "markdown": "`malloc( m * n * sizeof(int8_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 70976,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e1139c20-8708-41d4-9102-a3fa6f2ee06b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2130,
                  "startColumn": 51,
                  "endLine": 2130,
                  "endColumn": 82,
                  "charOffset": 70470,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int32_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int32_t)",
                      "markdown": "`malloc( m * n * sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 70470,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f5e28b88-1a3a-4093-aba6-fbbfdf1c03f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2120,
                  "startColumn": 51,
                  "endLine": 2120,
                  "endColumn": 80,
                  "charOffset": 69966,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(float)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(float)",
                      "markdown": "`malloc( m * n * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69966,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c8277517-beb3-4fe0-bf7d-ffcb3c9db184",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2110,
                  "startColumn": 51,
                  "endLine": 2110,
                  "endColumn": 83,
                  "charOffset": 69458,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(bfloat16)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(bfloat16)",
                      "markdown": "`malloc( m * n * sizeof(bfloat16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69458,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f31da6f0-8279-4e1e-b410-f376e19c6cd2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2099,
                  "startColumn": 31,
                  "endLine": 2099,
                  "endColumn": 72,
                  "charOffset": 69048,
                  "charLength": 41,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_post_op_matrix_add )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_post_op_matrix_add )",
                      "markdown": "`malloc( sizeof( aocl_post_op_matrix_add )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69048,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bceb65d7-cbc0-4496-9ad8-890ac17b2a02",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2083,
                  "startColumn": 44,
                  "endLine": 2083,
                  "endColumn": 82,
                  "charOffset": 68283,
                  "charLength": 38,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( C_DSCALE_type )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( C_DSCALE_type )",
                      "markdown": "`malloc( n_zp * sizeof( C_DSCALE_type )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 68283,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-399dcbe2-6ecd-4cd6-9f9f-ab7f9297f9e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2070,
                  "startColumn": 48,
                  "endLine": 2070,
                  "endColumn": 80,
                  "charOffset": 67770,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( uint8_t )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( uint8_t )",
                      "markdown": "`malloc( n_zp * sizeof( uint8_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67770,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-58ffe852-1d3b-46a0-ba1e-0a699f46c6e7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2059,
                  "startColumn": 48,
                  "endLine": 2059,
                  "endColumn": 79,
                  "charOffset": 67226,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( int8_t )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( int8_t )",
                      "markdown": "`malloc( n_zp * sizeof( int8_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67226,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-49f3cadc-74c6-4460-b577-9e98162cbbf9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2048,
                  "startColumn": 48,
                  "endLine": 2048,
                  "endColumn": 80,
                  "charOffset": 66681,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( int32_t )",
                      "markdown": "`malloc( n_zp * sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 66681,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-66610a6c-0433-4fc3-9590-0d300def46c5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2037,
                  "startColumn": 48,
                  "endLine": 2037,
                  "endColumn": 78,
                  "charOffset": 66138,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( float )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( float )",
                      "markdown": "`malloc( n_zp * sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 66138,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0d8ff4e9-bbb5-4f84-b4cd-883560c16a80",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2026,
                  "startColumn": 48,
                  "endLine": 2026,
                  "endColumn": 81,
                  "charOffset": 65591,
                  "charLength": 33,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( bfloat16 )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( bfloat16 )",
                      "markdown": "`malloc( n_zp * sizeof( bfloat16 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 65591,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-646148b0-cb90-4288-9b0d-9133c593146f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2010,
                  "startColumn": 42,
                  "endLine": 2010,
                  "endColumn": 81,
                  "charOffset": 64810,
                  "charLength": 39,
                  "snippet": {
                    "text": "malloc( n_scale * sizeof( DSCALE_type )",
                    "rendered": {
                      "text": "malloc( n_scale * sizeof( DSCALE_type )",
                      "markdown": "`malloc( n_scale * sizeof( DSCALE_type )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 64810,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6946eb59-3138-4f45-8055-eed7a9380736",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1982,
                  "startColumn": 24,
                  "endLine": 1982,
                  "endColumn": 58,
                  "charOffset": 63951,
                  "charLength": 34,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_post_op_sum )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_post_op_sum )",
                      "markdown": "`malloc( sizeof( aocl_post_op_sum )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 63951,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-aad1ca29-7141-4c44-b165-1a81baae98e7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1950,
                  "startColumn": 62,
                  "endLine": 1950,
                  "endColumn": 85,
                  "charOffset": 62370,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc( sizeof( float )",
                    "rendered": {
                      "text": "malloc( sizeof( float )",
                      "markdown": "`malloc( sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 62370,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-86db3e7d-a3f9-4c12-b916-b1f1c9d289bb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1945,
                  "startColumn": 63,
                  "endLine": 1945,
                  "endColumn": 86,
                  "charOffset": 62121,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc( sizeof( float )",
                    "rendered": {
                      "text": "malloc( sizeof( float )",
                      "markdown": "`malloc( sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 62121,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5a577a43-37bf-47d4-8f26-e63277f72b92",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1935,
                  "startColumn": 62,
                  "endLine": 1935,
                  "endColumn": 87,
                  "charOffset": 61613,
                  "charLength": 25,
                  "snippet": {
                    "text": "malloc( sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( sizeof( int32_t )",
                      "markdown": "`malloc( sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 61613,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dbca66e0-7a78-4030-8c41-079804bdd937",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1930,
                  "startColumn": 63,
                  "endLine": 1930,
                  "endColumn": 88,
                  "charOffset": 61362,
                  "charLength": 25,
                  "snippet": {
                    "text": "malloc( sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( sizeof( int32_t )",
                      "markdown": "`malloc( sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 61362,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-73e384bc-3297-4582-9ff0-786b2a0937c2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1895,
                  "startColumn": 68,
                  "endLine": 1895,
                  "endColumn": 91,
                  "charOffset": 59490,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc( sizeof( float )",
                    "rendered": {
                      "text": "malloc( sizeof( float )",
                      "markdown": "`malloc( sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 59490,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-342b53fc-1221-4473-9e1d-0a5c0dee539a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1886,
                  "startColumn": 68,
                  "endLine": 1886,
                  "endColumn": 93,
                  "charOffset": 59075,
                  "charLength": 25,
                  "snippet": {
                    "text": "malloc( sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( sizeof( int32_t )",
                      "markdown": "`malloc( sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 59075,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1a022724-3a2d-43b2-ab37-c2b73b96e6f1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1866,
                  "startColumn": 68,
                  "endLine": 1866,
                  "endColumn": 91,
                  "charOffset": 57980,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc( sizeof( float )",
                    "rendered": {
                      "text": "malloc( sizeof( float )",
                      "markdown": "`malloc( sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 57980,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4c5766e9-82f9-4cbe-b7ef-ceadf725928d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1857,
                  "startColumn": 68,
                  "endLine": 1857,
                  "endColumn": 93,
                  "charOffset": 57565,
                  "charLength": 25,
                  "snippet": {
                    "text": "malloc( sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( sizeof( int32_t )",
                      "markdown": "`malloc( sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 57565,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1c77e309-c0ce-4e06-b31a-6631fd4d20da",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1833,
                  "startColumn": 28,
                  "endLine": 1833,
                  "endColumn": 80,
                  "charOffset": 56385,
                  "charLength": 52,
                  "snippet": {
                    "text": "malloc( num_eltwise * sizeof( aocl_post_op_eltwise )",
                    "rendered": {
                      "text": "malloc( num_eltwise * sizeof( aocl_post_op_eltwise )",
                      "markdown": "`malloc( num_eltwise * sizeof( aocl_post_op_eltwise )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56385,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cb0a4039-af64-49bc-b507-33cc3e561027",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1802,
                  "startColumn": 43,
                  "endLine": 1802,
                  "endColumn": 74,
                  "charOffset": 55476,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( n * sizeof( BIAS_type )",
                    "rendered": {
                      "text": "malloc( n * sizeof( BIAS_type )",
                      "markdown": "`malloc( n * sizeof( BIAS_type )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55476,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3174a78a-27c3-4d74-b097-5bc89387c672",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1789,
                  "startColumn": 47,
                  "endLine": 1789,
                  "endColumn": 76,
                  "charOffset": 54915,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( n * sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( n * sizeof( int32_t )",
                      "markdown": "`malloc( n * sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54915,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-72d833f0-ace9-455d-9530-0d830370da1d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1778,
                  "startColumn": 47,
                  "endLine": 1778,
                  "endColumn": 75,
                  "charOffset": 54324,
                  "charLength": 28,
                  "snippet": {
                    "text": "malloc( n * sizeof( int8_t )",
                    "rendered": {
                      "text": "malloc( n * sizeof( int8_t )",
                      "markdown": "`malloc( n * sizeof( int8_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54324,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-10c32db0-5790-40f8-9b7f-200beb2077eb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1767,
                  "startColumn": 47,
                  "endLine": 1767,
                  "endColumn": 74,
                  "charOffset": 53737,
                  "charLength": 27,
                  "snippet": {
                    "text": "malloc( n * sizeof( float )",
                    "rendered": {
                      "text": "malloc( n * sizeof( float )",
                      "markdown": "`malloc( n * sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53737,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e4c00b75-f680-40a6-81a0-bca108a1523f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1756,
                  "startColumn": 47,
                  "endLine": 1756,
                  "endColumn": 77,
                  "charOffset": 53144,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( n * sizeof( bfloat16 )",
                    "rendered": {
                      "text": "malloc( n * sizeof( bfloat16 )",
                      "markdown": "`malloc( n * sizeof( bfloat16 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53144,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-14c918b0-8ab0-4f74-87bb-da4397aa2eb7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1744,
                  "startColumn": 29,
                  "endLine": 1744,
                  "endColumn": 64,
                  "charOffset": 52647,
                  "charLength": 35,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_post_op_bias )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_post_op_bias )",
                      "markdown": "`malloc( sizeof( aocl_post_op_bias )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52647,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}