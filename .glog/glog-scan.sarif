{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-91060ff4-6938-4ce5-80db-fd377f53f12d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming. The function call:\n\n```cpp\nmemcpy(reorder_buf_addr, input_buf_addr, (k * sizeof(int8_t)));\n```\n\nis potentially unsafe because it does not ensure that the destination buffer (`reorder_buf_addr`) is large enough to hold the data being copied from the source buffer (`input_buf_addr`). This can lead to a buffer overflow, which is a common security vulnerability that can result in undefined behavior, including data corruption, crashes, or even code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` or `std::copy` (in C++) which provide better safety guarantees.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the size of the destination buffer is checked before performing the copy operation. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <cstdint> // Required for int8_t\n\nvoid safe_memcpy(int8_t* reorder_buf_addr, size_t reorder_buf_size, const int8_t* input_buf_addr, size_t k) {\n    size_t bytes_to_copy = k * sizeof(int8_t);\n    if (bytes_to_copy <= reorder_buf_size) {\n        memcpy(reorder_buf_addr, input_buf_addr, bytes_to_copy);\n    } else {\n        // Handle error: destination buffer is not large enough\n        // This could be logging an error, throwing an exception, etc.\n    }\n}\n```\n\n### Library Dependencies\n\nThe following libraries are required for the code example to execute properly:\n\n- `<cstring>`: Provides the `memcpy` function.\n- `<cstdint>`: Provides fixed-width integer types like `int8_t`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bf5d0354-00c1-451c-838f-ddc9cc10f75c",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-41e5e262-b709-48ca-8cda-7cccb61de713",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-368e1d56-0b52-4bd1-9834-042b5435f7d0",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-4d06f8a9-8fd1-474b-8f6b-3bea5ec6616e",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-6508f4d7-1bd4-4b8f-b414-e51e0c8941da",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-55dbff06-9ee0-49cc-b131-f99022815c0b",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-609492a8-e24e-43b1-aed2-49e518513384",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-7a266a4b-4609-4caa-850f-00053d664c2d",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-0b221e9a-fcd2-47e1-93d6-d8d9a609a411",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-ea3b11c1-6219-4a9f-bf09-810bd91cba2e",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-36069aef-2c39-4007-9eb7-037b4db5fd6c",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-b962ca89-9cd8-4618-a909-a3822e95bff1",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-0dfc48a2-a531-47c3-8124-87889bed392d",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-ffc20552-7777-441e-ad3b-881832fac24b",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-7e415b74-ce73-47a3-9ea5-3e4d7aa0aa0a",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-c7de9693-fddc-4f15-a240-1c5a0b00093e",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-4d00887b-bbc4-454b-98e5-ad835a4740ff",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-d74ae544-e561-485a-91b2-30871b96692e",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-db39c21b-4f48-47dd-ad25-8aada5142271",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-d08251ba-8c29-4abd-b6d2-40894385fa82",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-7224e45f-c441-4d74-87ae-1a9df647d05a",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-43ec0f69-bd75-4f5f-b62e-879c35661ffc",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-d9d1b97c-8f10-48d0-a205-7aee098e8609",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-e299a7b8-8c55-4eb2-8f63-2d5ce97ff33d",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-664def03-38b1-4ab8-9550-77530163a49a",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-d8fd412f-b07b-4fa8-8e6e-a833c3b1411e",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-8d8eb45d-4375-4edc-987e-15762d19b8dd",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-d51a8b95-4300-47da-afac-a99e3036622d",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-fa1dd3a5-09bf-4b9a-b463-76a0523ba4cc",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-dc354abc-81b6-467a-95f2-79304f9600ca",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-294dcc73-358b-4e43-9be0-d75eda2d532c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability identified with the C function `memcpy` in the context of C++ programming arises from the improper use of the function, specifically in the expression `memcpy(y, x, n << 3)`. This expression can lead to several issues, including buffer overflows, if the size of the destination buffer `y` is not properly managed. The left shift operation `n << 3` multiplies `n` by 8, which can result in copying more bytes than intended, potentially overwriting adjacent memory and leading to undefined behavior, security vulnerabilities, or program crashes.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Ensure that the size of the destination buffer is sufficient to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` in C++ which provide better safety guarantees.\n3. **Boundary Checks**: Implement boundary checks to ensure that the source and destination buffers are not overrun.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\nvoid safe_memcpy(void* dest, const void* src, size_t n, size_t dest_size) {\n    // Calculate the number of bytes to copy\n    size_t bytes_to_copy = std::min(n << 3, dest_size);\n    // Perform the copy operation safely\n    memcpy(dest, src, bytes_to_copy);\n}\n\n// Example usage\nint main() {\n    char x[64];\n    char y[64];\n    size_t n = 8; // Example value\n\n    // Ensure y has enough space\n    safe_memcpy(y, x, n, sizeof(y));\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for the `memcpy` function.\n- `<algorithm>`: Required for the `std::min` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7451acf4-ace9-4755-8483-a79af3056523",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, data corruption, or undefined behavior. The specific vulnerability sink in the code example `memcpy(y, x, n << 2)` involves shifting the value of `n` by 2 bits to the left, which multiplies `n` by 4. This operation can lead to copying more bytes than intended if `n` is not properly validated, resulting in a buffer overflow if the destination buffer `y` is not large enough to accommodate the copied data.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Ensure that the size of the source and destination buffers are properly validated before performing the copy operation.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` or `std::copy` in C++ which provide better safety checks.\n3. **Bounds Checking**: Always perform bounds checking to ensure that the destination buffer is large enough to hold the data being copied.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer `y` is large enough to hold `n << 2` bytes. Additionally, consider using `std::copy` for better safety:\n\n```cpp\n#include <algorithm> // for std::copy\n#include <cstring>   // for memcpy\n\nvoid safeCopy(char* y, const char* x, size_t n, size_t y_size) {\n    if (y_size >= (n << 2)) {\n        std::copy(x, x + (n << 2), y);\n    } else {\n        // Handle error: destination buffer is not large enough\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<algorithm>`: Provides the `std::copy` function.\n- `<cstring>`: Provides the `memcpy` function.\n\n### Relevant Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5efea088-93ad-439c-ae29-95fc71f56e6a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question is related to the use of the `memcpy` function in C/C++ programming. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied is not properly validated, which can lead to buffer overflows. This can result in undefined behavior, including data corruption, crashes, and potential security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the size of the memory to be copied is determined by the expression `(k * sizeof(BLIS_FLOAT))`. If `k` is not properly validated, it could lead to copying more data than the destination buffer can hold, resulting in a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Input:** Ensure that the size of the data to be copied does not exceed the size of the destination buffer.\n2. **Use Safer Functions:** Consider using safer alternatives like `memmove` or `std::copy` in C++ which provide additional safety checks.\n3. **Boundary Checks:** Implement boundary checks to ensure that the source and destination buffers are properly sized.\n4. **Static Analysis Tools:** Use static analysis tools to detect potential buffer overflows in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the size of the data being copied does not exceed the size of the destination buffer. Here is a revised version of the code snippet with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming BLIS_FLOAT is defined elsewhere\n// Define the size of the destination buffer\nconst size_t reorder_buf_size = /* size of reorder_buf_addr in bytes */;\n\nvoid safe_memcpy(void* reorder_buf_addr, const void* input_buf_addr, size_t k) {\n    size_t copy_size = k * sizeof(BLIS_FLOAT);\n    // Ensure we do not copy more than the destination buffer can hold\n    copy_size = std::min(copy_size, reorder_buf_size);\n    memcpy(reorder_buf_addr, input_buf_addr, copy_size);\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following libraries are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-14a0af90-a0de-4a61-b722-9ae3eeace5e0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability often occurs when the size of the memory allocation is miscalculated or unchecked, leading to insufficient memory being allocated or excessive memory usage.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `malloc`:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-a35c64fa-7f9a-4e0f-9332-1bf2ad57d9fa",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability often occurs when the size of the memory allocation is miscalculated or unchecked, leading to insufficient memory being allocated or excessive memory usage.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `malloc`:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-25688913-0177-4170-87c6-351d12857145",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size of the memory allocation is miscalculated or unchecked, which can result in insufficient memory being allocated or excessive memory consumption.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use `calloc` for Zero Initialization**: Consider using `calloc` instead of `malloc` if zero-initialization of the allocated memory is desired.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that addresses the vulnerability:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    double* array = static_cast<double*>(malloc(n * sizeof(double)));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<double>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Links\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-2bb78121-0d6e-4df8-919d-8e5b91a8f584",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or improper memory access. In the provided code snippet, `malloc(n * num_groups * sizeof(float))`, the vulnerability may occur if the multiplication of `n` and `num_groups` results in an integer overflow, leading to insufficient memory allocation and subsequent undefined behavior.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `n` and `num_groups` are within a safe range to prevent integer overflow.\n2. **Use Safer Functions**: Consider using safer alternatives like `calloc` which automatically initializes the allocated memory to zero.\n3. **Check for Overflow**: Before performing the multiplication, check if the result will overflow.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t n = 10; // Example value\n    size_t num_groups = 5; // Example value\n\n    // Check for overflow\n    if (n > 0 && num_groups > 0 && n <= std::numeric_limits<size_t>::max() / num_groups) {\n        float* array = (float*)malloc(n * num_groups * sizeof(float));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-2097ab1e-cf28-4b1c-9869-9e21a0fcb06a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, `malloc(m * num_groups * sizeof(float))`, the vulnerability may occur if the multiplication of `m` and `num_groups` results in an integer overflow, leading to insufficient memory allocation and potential buffer overflow.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `num_groups` are within a safe range to prevent integer overflow.\n2. **Use Safer Functions**: Consider using safer alternatives like `calloc` which automatically initializes the allocated memory to zero.\n3. **Check for Overflow**: Before performing the multiplication, check if the result will overflow.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t m = 10; // Example value\n    size_t num_groups = 20; // Example value\n\n    // Check for overflow\n    if (m > 0 && num_groups > 0 && m <= std::numeric_limits<size_t>::max() / num_groups) {\n        size_t total_size = m * num_groups;\n        float* array = (float*)malloc(total_size * sizeof(float));\n\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To use `std::numeric_limits` for checking overflow.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-ee4eaba2-b087-463c-a765-7ff1c3ad49b8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. This vulnerability can lead to various issues such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not managed correctly. In the specific case of `malloc(n * num_groups * sizeof(bfloat16))`, the vulnerability may occur due to incorrect calculation of the total memory size needed, potentially leading to insufficient memory allocation or integer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Input**: Ensure that all inputs used in the calculation of memory size are validated to prevent integer overflow.\n2. **Check for Overflow**: Use safe arithmetic operations to check for potential overflows before performing the multiplication.\n3. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n5. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming bfloat16 is a defined type\ntypedef float bfloat16; // Example definition\n\nvoid allocateMemory(size_t n, size_t num_groups) {\n    // Check for potential overflow\n    if (n > 0 && num_groups > 0 && n <= std::numeric_limits<size_t>::max() / num_groups) {\n        size_t total_size = n * num_groups * sizeof(bfloat16);\n        bfloat16* buffer = static_cast<bfloat16*>(malloc(total_size));\n\n        if (buffer == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return;\n        }\n\n        // Use the buffer...\n\n        // Free the allocated memory\n        free(buffer);\n    } else {\n        std::cerr << \"Integer overflow detected or invalid input\" << std::endl;\n    }\n}\n\nint main() {\n    size_t n = 10;\n    size_t num_groups = 5;\n    allocateMemory(n, num_groups);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To use `std::numeric_limits` for checking maximum size limits.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1a866294-b91d-4153-b2ad-f75d60d7e024",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to memory allocation issues such as buffer overflows, memory leaks, or improper memory access. In the provided code snippet, the expression `malloc(m * num_groups * sizeof(bfloat16))` is used to allocate memory. If the values of `m` or `num_groups` are not properly validated, this can result in an integer overflow, leading to insufficient memory allocation and potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `num_groups` are validated to prevent integer overflow. They should be within a reasonable range and should not cause the multiplication to exceed the maximum value of `size_t`.\n\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n3. **Use Safer Functions**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n\n4. **Integer Overflow Checks**: Before performing the multiplication, check if the result will overflow.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming bfloat16 is a defined type\ntypedef float bfloat16; // Example definition\n\nvoid allocateMemory(size_t m, size_t num_groups) {\n    // Check for potential overflow\n    if (m > 0 && num_groups > 0 && m <= std::numeric_limits<size_t>::max() / num_groups) {\n        size_t total_size = m * num_groups * sizeof(bfloat16);\n        bfloat16* buffer = (bfloat16*)malloc(total_size);\n\n        if (buffer == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            // Handle allocation failure\n        } else {\n            // Use the buffer\n            // ...\n\n            // Free the allocated memory\n            free(buffer);\n        }\n    } else {\n        std::cerr << \"Integer overflow detected or invalid input\" << std::endl;\n    }\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t num_groups = 5; // Example value\n    allocateMemory(m, num_groups);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To use `std::numeric_limits` for checking maximum size.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-bdea8071-53b8-4304-9400-73b7fb81e16c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the specific case of `malloc(sizeof(aocl_pre_op_sf))`, the vulnerability may occur if `aocl_pre_op_sf` is not a type but rather a variable or an expression, leading to incorrect memory allocation size. This can result in buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Size Calculation**: Always use `sizeof` with the type, not the variable, to ensure the correct amount of memory is allocated.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage memory automatically.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or `memset` to initialize allocated memory to prevent undefined behavior from uninitialized memory access.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <cstring>  // For memset\n\n// Assuming aocl_pre_op_sf is a type\ntypedef struct {\n    // Structure members\n} aocl_pre_op_sf;\n\nint main() {\n    // Correct usage of malloc with sizeof(type)\n    aocl_pre_op_sf* ptr = (aocl_pre_op_sf*)malloc(sizeof(aocl_pre_op_sf));\n    \n    if (ptr == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize allocated memory\n    memset(ptr, 0, sizeof(aocl_pre_op_sf));\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-ed660336-8417-41b5-8bfe-a9e54c17869a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the specific case of `malloc(sizeof(aocl_pre_op_sf))`, the vulnerability may occur if `aocl_pre_op_sf` is not a type but rather a variable or an expression, leading to incorrect memory allocation size. This can result in buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Size Calculation**: Always use `sizeof` with the type, not the variable, to ensure the correct amount of memory is allocated.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage memory automatically.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or `memset` to initialize allocated memory to prevent undefined behavior from uninitialized memory access.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <cstring>  // For memset\n\n// Assuming aocl_pre_op_sf is a type\ntypedef struct {\n    // Structure members\n} aocl_pre_op_sf;\n\nint main() {\n    // Correct usage of malloc with sizeof(type)\n    aocl_pre_op_sf* ptr = (aocl_pre_op_sf*)malloc(sizeof(aocl_pre_op_sf));\n    \n    if (ptr == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize allocated memory\n    memset(ptr, 0, sizeof(aocl_pre_op_sf));\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-a267cf62-f8b4-43a1-bfdf-7c42b9270e91",
              "help": {
                "text": "",
                "markdown": "### Detected Issue with C Function (malloc) Vulnerability in C++\n\nThe vulnerability arises from the improper use of the `malloc` function in C++, specifically when allocating memory for a data structure or object. In the provided example, `malloc(sizeof(aocl_group_post_op))` is used, which can lead to several issues:\n\n1. **Incorrect Size Calculation**: If `aocl_group_post_op` is a type or a pointer, `sizeof` might not return the expected size, leading to insufficient memory allocation.\n2. **Type Safety**: `malloc` returns a `void*`, which requires explicit casting, potentially leading to type safety issues.\n3. **Memory Leaks**: If the allocated memory is not properly managed or freed, it can lead to memory leaks.\n\n### General Mitigation Advice\n\n- **Use `new` Operator**: In C++, prefer using the `new` operator for memory allocation, which is type-safe and automatically calculates the correct size.\n- **Check for Null Pointers**: Always check if the memory allocation was successful by verifying that the pointer is not `NULL`.\n- **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed using `delete` or `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nReplace the `malloc` call with the `new` operator for better type safety and automatic size calculation:\n\n```cpp\n#include <iostream>\n\n// Assuming aocl_group_post_op is a struct or class\nstruct aocl_group_post_op {\n    // Members of the struct\n};\n\nint main() {\n    // Use new instead of malloc\n    aocl_group_post_op* post_op = new aocl_group_post_op;\n\n    // Check if allocation was successful\n    if (!post_op) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    delete post_op;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe above code does not require any additional library dependencies beyond the standard C++ library.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-0511eab2-31e7-4804-8f0e-6dad28beebc0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, the expression used in `malloc` may result in incorrect memory allocation if the calculated size exceeds the available memory or if the multiplication results in an integer overflow.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in size calculations are validated to prevent integer overflow.\n2. **Use Safe Functions**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Limit Memory Usage**: Implement limits on memory allocation to prevent excessive memory usage.\n\n### Source Code Fix Recommendation\n\nTo mitigate the specific vulnerability in the code snippet, you can perform checks to prevent integer overflow and ensure successful memory allocation:\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming bfloat16 is defined elsewhere\ntypedef float bfloat16; // Example definition\n\nvoid* safe_malloc(size_t num_groups, size_t scale_factor_len) {\n    size_t max_size = std::numeric_limits<size_t>::max() / sizeof(bfloat16);\n    if (num_groups > max_size / scale_factor_len) {\n        std::cerr << \"Integer overflow detected during memory allocation.\" << std::endl;\n        return nullptr;\n    }\n\n    size_t total_size = num_groups * scale_factor_len * sizeof(bfloat16);\n    void* ptr = malloc(total_size);\n    if (!ptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n    }\n    return ptr;\n}\n\nint main() {\n    size_t num_groups = 10; // Example value\n    size_t scale_factor_len = 20; // Example value\n\n    bfloat16* data = static_cast<bfloat16*>(safe_malloc(num_groups, scale_factor_len));\n    if (data) {\n        // Use the allocated memory\n        free(data);\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access numeric limits for data types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-2edf2fa3-7194-4b19-8190-04a62735dc8d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, the expression used in `malloc`:\n\n```c\nmalloc(num_groups * scale_factor_len * sizeof(float))\n```\n\ncan lead to an integer overflow if the product of `num_groups` and `scale_factor_len` exceeds the maximum value representable by an `int`. This overflow can result in allocating less memory than intended, leading to buffer overflows when the allocated memory is accessed.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `num_groups` and `scale_factor_len` are within a safe range to prevent integer overflow.\n2. **Use Safer Functions**: Consider using safer memory allocation functions that check for overflow, such as `calloc`, which also initializes the allocated memory to zero.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Smart Pointers**: In C++, prefer using smart pointers (e.g., `std::unique_ptr`, `std::shared_ptr`) to manage dynamic memory automatically.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, you can use `calloc` to allocate memory safely and check for potential overflows:\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nvoid allocateMemory(size_t num_groups, size_t scale_factor_len) {\n    if (num_groups > 0 && scale_factor_len > 0 &&\n        num_groups <= std::numeric_limits<size_t>::max() / scale_factor_len) {\n        float* data = (float*)calloc(num_groups * scale_factor_len, sizeof(float));\n        if (data == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return;\n        }\n        // Use the allocated memory\n        // ...\n\n        // Free the allocated memory\n        free(data);\n    } else {\n        std::cerr << \"Integer overflow detected or invalid input\" << std::endl;\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: For checking the maximum value of `size_t`.\n- `<cstdlib>`: For memory allocation functions like `calloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-cbccc972-1a11-4e25-b5c2-f18e2937c182",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper memory allocation using the `malloc` function. In this specific case, the vulnerability is due to the incorrect size being passed to `malloc`. The expression `malloc(sizeof(aocl_pre_op_sf))` is used, which may not allocate the correct amount of memory if `aocl_pre_op_sf` is a pointer or an incomplete type. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used on the correct type. If `aocl_pre_op_sf` is a pointer, use the type it points to.\n2. **Prefer `new` in C++**: In C++, prefer using `new` and `delete` for memory management instead of `malloc` and `free`.\n3. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n4. **Use Smart Pointers**: Consider using smart pointers like `std::unique_ptr` or `std::shared_ptr` for automatic memory management.\n\n### Source Code Fix Recommendation\n\nAssuming `aocl_pre_op_sf` is a type and not a pointer, the correct usage would be:\n\n```cpp\n#include <cstdlib> // for malloc and free\n\n// Assuming aocl_pre_op_sf is a type\naocl_pre_op_sf* ptr = (aocl_pre_op_sf*)malloc(sizeof(aocl_pre_op_sf));\nif (ptr == NULL) {\n    // Handle allocation failure\n}\n\n// Use the allocated memory\n\nfree(ptr);\n```\n\nIf `aocl_pre_op_sf` is a pointer type, ensure you allocate the correct size:\n\n```cpp\n#include <cstdlib> // for malloc and free\n\n// Assuming aocl_pre_op_sf is a pointer to a type\naocl_pre_op_sf* ptr = (aocl_pre_op_sf*)malloc(sizeof(*ptr));\nif (ptr == NULL) {\n    // Handle allocation failure\n}\n\n// Use the allocated memory\n\nfree(ptr);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstdlib>`: This library is required for using `malloc` and `free`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-49ca4fec-59bb-4172-8eb7-b5483978a44e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, the expression `malloc(num_groups * zp_vec_length * sizeof(int8_t))` is used to allocate memory. If `num_groups` or `zp_vec_length` are not properly validated, this can result in an integer overflow, leading to insufficient memory allocation and potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in memory allocation calculations are validated to prevent integer overflow.\n2. **Use Safer Functions**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Limit Memory Usage**: Implement limits on the maximum amount of memory that can be allocated to prevent excessive memory usage.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t num_groups = /* some value */;\n    size_t zp_vec_length = /* some value */;\n\n    // Check for potential overflow\n    if (num_groups > 0 && zp_vec_length > 0 && \n        num_groups <= std::numeric_limits<size_t>::max() / zp_vec_length) {\n        \n        size_t total_size = num_groups * zp_vec_length * sizeof(int8_t);\n        int8_t* buffer = static_cast<int8_t*>(malloc(total_size));\n\n        if (buffer == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n        // Use the buffer...\n\n        free(buffer);\n    } else {\n        std::cerr << \"Invalid input size, potential overflow detected\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To use `std::numeric_limits` for checking potential overflow.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-83c75db4-0aee-4082-8f76-36c71cc5402b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(sizeof(aocl_pre_op_zp))`, the vulnerability may occur if `aocl_pre_op_zp` is a pointer or an incomplete type, leading to incorrect memory allocation size. This can result in insufficient memory being allocated, causing potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Size Calculation**: Always ensure that the size passed to `malloc` is correct. If `aocl_pre_op_zp` is a pointer, use the size of the type it points to.\n2. **Use `sizeof` Correctly**: Use `sizeof(*aocl_pre_op_zp)` if `aocl_pre_op_zp` is a pointer to allocate memory for the type it points to.\n3. **Check for NULL**: Always check the return value of `malloc` for `NULL` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers for automatic memory management.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for malloc\n#include <iostream> // for std::cerr\n\n// Assuming aocl_pre_op_zp is a pointer to a type, e.g., int\ntypedef int aocl_pre_op_zp; // Example type definition\n\nint main() {\n    // Corrected memory allocation\n    aocl_pre_op_zp* ptr = (aocl_pre_op_zp*)malloc(sizeof(aocl_pre_op_zp));\n    \n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input/output operations, such as error messages.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-5cb15052-8f4a-4e56-bff3-aa5fff357e0d",
              "help": {
                "text": "",
                "markdown": "### Detected Issue with C Function (malloc) Vulnerability in C++\n\nThe vulnerability arises from the improper use of the `malloc` function in C++, specifically when allocating memory for a data structure or object. The issue is that `malloc` is being used with `sizeof(aocl_pre_op)`, which may not correctly allocate the required memory if `aocl_pre_op` is a pointer or an incomplete type. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Use `new` Operator**: In C++, prefer using the `new` operator for memory allocation, which automatically calculates the correct size for the object.\n2. **Check for NULL**: Always check the result of `malloc` for `NULL` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used on the correct type, especially if `aocl_pre_op` is a pointer or an incomplete type.\n4. **Initialize Memory**: Consider using `calloc` instead of `malloc` if you need the memory to be initialized to zero.\n5. **Free Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n\n// Assuming aocl_pre_op is a struct or class\nstruct aocl_pre_op {\n    // Members of the struct\n};\n\nint main() {\n    // Correct usage of malloc\n    aocl_pre_op* ptr = (aocl_pre_op*)malloc(sizeof(aocl_pre_op));\n    if (ptr == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstdlib>`: This library is required for using `malloc` and `free` functions.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-8d599087-a002-4733-9e9c-d00748b5c676",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This can occur if the size calculation for `malloc` is incorrect, leading to insufficient memory allocation. In the provided example, the expression `malloc(n_scale * sizeof(DSCALE_type))` may be vulnerable if `n_scale` is not properly validated or if `DSCALE_type` is not correctly defined, leading to potential security risks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `n_scale` is validated to be within a safe range to prevent excessive memory allocation.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `calloc` for zero-initialized memory allocation or smart pointers in C++ for automatic memory management.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <iostream> // For std::cerr\n\ntypedef int DSCALE_type; // Example type definition\n\nvoid exampleFunction(size_t n_scale) {\n    // Validate n_scale to prevent excessive allocation\n    if (n_scale == 0 || n_scale > SIZE_MAX / sizeof(DSCALE_type)) {\n        std::cerr << \"Invalid scale size\" << std::endl;\n        return;\n    }\n\n    // Allocate memory safely\n    DSCALE_type* scaleArray = static_cast<DSCALE_type*>(malloc(n_scale * sizeof(DSCALE_type)));\n    if (scaleArray == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(scaleArray);\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-3e14df86-dd2b-4732-8fa0-1392bff05004",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. Specifically, the use of `malloc(m * n * sizeof(float))` can be problematic if the multiplication of `m` and `n` results in an integer overflow, causing `malloc` to allocate insufficient memory. This can lead to writing beyond the allocated memory space, resulting in a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Check for Integer Overflow**: Before performing the multiplication, ensure that the result will not exceed the maximum value representable by the data type.\n2. **Use Safer Functions**: Consider using safer alternatives or libraries that handle memory allocation more securely.\n3. **Validate Input**: Ensure that the values of `m` and `n` are within expected ranges and are not negative.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nbool safeMultiply(size_t a, size_t b, size_t& result) {\n    if (a == 0 || b == 0) {\n        result = 0;\n        return true;\n    }\n    if (a > std::numeric_limits<size_t>::max() / b) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safeMultiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    float* array = static_cast<float*>(malloc(size * sizeof(float)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the array...\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-c95ce3a5-ce72-4118-b0c9-ef23331ab844",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to various issues such as buffer overflows, memory leaks, or integer overflows. In the specific case of `malloc(m * n * sizeof(C_DSCALE_type))`, the vulnerability may occur if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation. This can cause undefined behavior, potentially allowing attackers to exploit the program.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory allocation more safely.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming C_DSCALE_type is defined somewhere\ntypedef int C_DSCALE_type;\n\nbool safe_multiply(size_t a, size_t b, size_t& result) {\n    if (a > 0 && b > 0 && a > (std::numeric_limits<size_t>::max() / b)) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safe_multiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected during multiplication!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    void* ptr = malloc(size * sizeof(C_DSCALE_type));\n    if (!ptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    free(ptr);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access numeric limits for data types.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-cfbd2ed7-3739-4792-8d0b-7c2cc91e601f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory leaks. Specifically, the expression `malloc(m * n * sizeof(int32_t))` can be vulnerable if the multiplication `m * n` results in an integer overflow, causing `malloc` to allocate less memory than intended. This can lead to writing beyond the allocated memory, resulting in undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Alternative Functions**: Consider using functions like `calloc` which automatically handle multiplication and zero-initialize the allocated memory.\n4. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    int32_t m = 1000; // Example values\n    int32_t n = 2000;\n\n    // Check for potential overflow\n    if (m > 0 && n > 0 && m <= std::numeric_limits<int32_t>::max() / n) {\n        int32_t* array = static_cast<int32_t*>(malloc(m * n * sizeof(int32_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access numeric limits of data types.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-e4557fba-6a3e-4883-abba-94f86f0609d8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or other undefined behaviors. Specifically, the expression `malloc(m * n * sizeof(int8_t))` can be problematic if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation and subsequent memory corruption when the allocated memory is accessed.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory management more safely.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n\n    // Check for overflow before multiplication\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        int8_t* array = static_cast<int8_t*>(malloc(m * n * sizeof(int8_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-2586e97c-de5c-456e-b91d-ee6bbd30aca1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or other undefined behaviors. Specifically, the expression `malloc(m * n * sizeof(int8_t))` can be problematic if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation and subsequent memory corruption when the allocated memory is accessed.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory management more safely.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n\n    // Check for overflow before multiplication\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        int8_t* array = static_cast<int8_t*>(malloc(m * n * sizeof(int8_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-18c120f1-6718-476b-8c44-a1a351d279e4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory leaks. Specifically, the expression `malloc(m * n * sizeof(int32_t))` can be vulnerable if the multiplication `m * n` results in an integer overflow, causing `malloc` to allocate less memory than intended. This can lead to writing beyond the allocated memory, resulting in undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Alternative Functions**: Consider using functions like `calloc` which automatically handle multiplication and zero-initialize the allocated memory.\n4. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    int32_t m = 1000; // Example values\n    int32_t n = 2000;\n\n    // Check for potential overflow\n    if (m > 0 && n > 0 && m <= std::numeric_limits<int32_t>::max() / n) {\n        int32_t* array = static_cast<int32_t*>(malloc(m * n * sizeof(int32_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access numeric limits of data types.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-6597b630-2ec5-4375-9120-2d0ecfdff5bd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. Specifically, the use of `malloc(m * n * sizeof(float))` can be problematic if the multiplication of `m` and `n` results in an integer overflow, causing `malloc` to allocate insufficient memory. This can lead to writing beyond the allocated memory space, resulting in a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Check for Integer Overflow**: Before performing the multiplication, ensure that the result will not exceed the maximum value representable by the data type.\n2. **Use Safer Functions**: Consider using safer alternatives or libraries that handle memory allocation more securely.\n3. **Validate Input**: Ensure that the values of `m` and `n` are within expected ranges and are not negative.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nbool safeMultiply(size_t a, size_t b, size_t& result) {\n    if (a == 0 || b == 0) {\n        result = 0;\n        return true;\n    }\n    if (a > std::numeric_limits<size_t>::max() / b) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safeMultiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    float* array = static_cast<float*>(malloc(size * sizeof(float)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the array...\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-e0b91819-74fc-4a16-abbb-2eaddcf67e02",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory corruption. Specifically, when using `malloc` to allocate memory, if the multiplication of the dimensions (`m * n * sizeof(bfloat16)`) results in an integer overflow, it can lead to allocating less memory than intended. This can cause buffer overflows when the program writes beyond the allocated memory, leading to undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Safer Functions**: Consider using safer memory allocation functions or libraries that handle overflow checks internally.\n4. **Static Analysis Tools**: Utilize static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of integer overflow in the `malloc` call, you can implement a check before performing the multiplication:\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming bfloat16 is a defined type\ntypedef float bfloat16;\n\nvoid* safeMalloc(size_t m, size_t n) {\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        size_t totalSize = m * n * sizeof(bfloat16);\n        return malloc(totalSize);\n    } else {\n        std::cerr << \"Integer overflow detected or invalid size parameters.\" << std::endl;\n        return nullptr;\n    }\n}\n\nint main() {\n    size_t m = 1000;\n    size_t n = 1000;\n    bfloat16* array = static_cast<bfloat16*>(safeMalloc(m, n));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    // Use the allocated memory\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-2bf4d8eb-42e6-4efe-a8e6-42212f3727d5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(sizeof(aocl_post_op_matrix_mul))`, the vulnerability may occur if the size of the type `aocl_post_op_matrix_mul` is not correctly calculated or if the type is not properly defined, leading to incorrect memory allocation.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct type or variable to allocate the appropriate amount of memory.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to ensure that memory allocation was successful.\n3. **Initialize Memory**: Consider using `calloc` instead of `malloc` to automatically initialize the allocated memory to zero.\n4. **Free Memory**: Ensure that all dynamically allocated memory is freed when no longer needed to prevent memory leaks.\n5. **Use Smart Pointers**: In C++, prefer using smart pointers (e.g., `std::unique_ptr`, `std::shared_ptr`) to manage dynamic memory automatically.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for malloc and free\n#include <iostream>\n\n// Assuming aocl_post_op_matrix_mul is a defined struct or class\nstruct aocl_post_op_matrix_mul {\n    // member variables\n};\n\nint main() {\n    // Correctly allocate memory for aocl_post_op_matrix_mul\n    aocl_post_op_matrix_mul* ptr = static_cast<aocl_post_op_matrix_mul*>(malloc(sizeof(aocl_post_op_matrix_mul)));\n    \n    // Check if malloc succeeded\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-c6c5e0af-2a93-4efd-bf7d-fadf0224184f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This can occur if the size calculation for `malloc` is incorrect, leading to insufficient memory allocation. In the provided example, the expression `malloc(n_scale * sizeof(DSCALE_type))` may be vulnerable if `n_scale` is not properly validated or if `DSCALE_type` is not correctly defined, leading to potential security risks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `n_scale` is validated to be within a safe range to prevent excessive memory allocation.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `calloc` for zero-initialized memory allocation or smart pointers in C++ for automatic memory management.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <iostream> // For std::cerr\n\ntypedef int DSCALE_type; // Example type definition\n\nvoid exampleFunction(size_t n_scale) {\n    // Validate n_scale to prevent excessive allocation\n    if (n_scale == 0 || n_scale > SIZE_MAX / sizeof(DSCALE_type)) {\n        std::cerr << \"Invalid scale size\" << std::endl;\n        return;\n    }\n\n    // Allocate memory safely\n    DSCALE_type* scaleArray = static_cast<DSCALE_type*>(malloc(n_scale * sizeof(DSCALE_type)));\n    if (scaleArray == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(scaleArray);\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-c3a566c3-4d47-4e6f-a87b-5f0e657e658b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. Specifically, the use of `malloc(m * n * sizeof(float))` can be problematic if the multiplication of `m` and `n` results in an integer overflow, causing `malloc` to allocate insufficient memory. This can lead to writing beyond the allocated memory space, resulting in a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Check for Integer Overflow**: Before performing the multiplication, ensure that the result will not exceed the maximum value representable by the data type.\n2. **Use Safer Functions**: Consider using safer alternatives or libraries that handle memory allocation more securely.\n3. **Validate Input**: Ensure that the values of `m` and `n` are within expected ranges and are not negative.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nbool safeMultiply(size_t a, size_t b, size_t& result) {\n    if (a == 0 || b == 0) {\n        result = 0;\n        return true;\n    }\n    if (a > std::numeric_limits<size_t>::max() / b) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safeMultiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    float* array = static_cast<float*>(malloc(size * sizeof(float)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the array...\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-9161757b-7990-4c55-b04a-d2cb38da4cd1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to various issues such as buffer overflows, memory leaks, or integer overflows. In the specific case of `malloc(m * n * sizeof(C_DSCALE_type))`, the vulnerability may occur if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation. This can cause undefined behavior, potentially allowing attackers to exploit the program.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory allocation more safely.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming C_DSCALE_type is defined somewhere\ntypedef int C_DSCALE_type;\n\nbool safe_multiply(size_t a, size_t b, size_t& result) {\n    if (a > 0 && b > 0 && a > (std::numeric_limits<size_t>::max() / b)) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safe_multiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected during multiplication!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    void* ptr = malloc(size * sizeof(C_DSCALE_type));\n    if (!ptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    free(ptr);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access numeric limits for data types.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-cb4de3c7-56e6-4bd9-a104-ca1d2c0306b2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory leaks. Specifically, the expression `malloc(m * n * sizeof(int32_t))` can be vulnerable if the multiplication `m * n` results in an integer overflow, causing `malloc` to allocate less memory than intended. This can lead to writing beyond the allocated memory, resulting in undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Alternative Functions**: Consider using functions like `calloc` which automatically handle multiplication and zero-initialize the allocated memory.\n4. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    int32_t m = 1000; // Example values\n    int32_t n = 2000;\n\n    // Check for potential overflow\n    if (m > 0 && n > 0 && m <= std::numeric_limits<int32_t>::max() / n) {\n        int32_t* array = static_cast<int32_t*>(malloc(m * n * sizeof(int32_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access numeric limits of data types.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-a0d27b20-71a9-4c0f-9f34-050497fd3ce7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or other undefined behaviors. Specifically, the expression `malloc(m * n * sizeof(int8_t))` can be problematic if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation and subsequent memory corruption when the allocated memory is accessed.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory management more safely.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n\n    // Check for overflow before multiplication\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        int8_t* array = static_cast<int8_t*>(malloc(m * n * sizeof(int8_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-b08736ce-39b7-4027-acf1-445cfddd7774",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or other undefined behaviors. Specifically, the expression `malloc(m * n * sizeof(int8_t))` can be problematic if the multiplication `m * n` results in an integer overflow, leading to insufficient memory allocation and subsequent memory corruption when the allocated memory is accessed.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using higher-level abstractions or libraries that handle memory management more safely.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n\n    // Check for overflow before multiplication\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        int8_t* array = static_cast<int8_t*>(malloc(m * n * sizeof(int8_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return EXIT_FAILURE;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input/output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-7c5db56d-a9ff-474c-ba0c-705d1c55a869",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory leaks. Specifically, the expression `malloc(m * n * sizeof(int32_t))` can be vulnerable if the multiplication `m * n` results in an integer overflow, causing `malloc` to allocate less memory than intended. This can lead to writing beyond the allocated memory, resulting in undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Alternative Functions**: Consider using functions like `calloc` which automatically handle multiplication and zero-initialize the allocated memory.\n4. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    int32_t m = 1000; // Example values\n    int32_t n = 2000;\n\n    // Check for potential overflow\n    if (m > 0 && n > 0 && m <= std::numeric_limits<int32_t>::max() / n) {\n        int32_t* array = static_cast<int32_t*>(malloc(m * n * sizeof(int32_t)));\n        if (array == nullptr) {\n            std::cerr << \"Memory allocation failed\" << std::endl;\n            return 1;\n        }\n\n        // Use the allocated memory\n\n        free(array);\n    } else {\n        std::cerr << \"Integer overflow detected\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access numeric limits of data types.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-eb695389-a7f0-4f43-8d77-4e227291c393",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. Specifically, the use of `malloc(m * n * sizeof(float))` can be problematic if the multiplication of `m` and `n` results in an integer overflow, causing `malloc` to allocate insufficient memory. This can lead to writing beyond the allocated memory space, resulting in a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Check for Integer Overflow**: Before performing the multiplication, ensure that the result will not exceed the maximum value representable by the data type.\n2. **Use Safer Functions**: Consider using safer alternatives or libraries that handle memory allocation more securely.\n3. **Validate Input**: Ensure that the values of `m` and `n` are within expected ranges and are not negative.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nbool safeMultiply(size_t a, size_t b, size_t& result) {\n    if (a == 0 || b == 0) {\n        result = 0;\n        return true;\n    }\n    if (a > std::numeric_limits<size_t>::max() / b) {\n        return false; // Overflow would occur\n    }\n    result = a * b;\n    return true;\n}\n\nint main() {\n    size_t m = 10; // Example value\n    size_t n = 20; // Example value\n    size_t size;\n\n    if (!safeMultiply(m, n, size)) {\n        std::cerr << \"Integer overflow detected!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    float* array = static_cast<float*>(malloc(size * sizeof(float)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the array...\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1ad61acf-6d7d-4318-91d1-f119f3c10ffd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential issues such as integer overflow, buffer overflow, or memory corruption. Specifically, when using `malloc` to allocate memory, if the multiplication of the dimensions (`m * n * sizeof(bfloat16)`) results in an integer overflow, it can lead to allocating less memory than intended. This can cause buffer overflows when the program writes beyond the allocated memory, leading to undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the values of `m` and `n` are within a safe range to prevent integer overflow.\n2. **Use Safe Multiplication**: Implement checks to detect potential overflows before performing the multiplication.\n3. **Use Safer Functions**: Consider using safer memory allocation functions or libraries that handle overflow checks internally.\n4. **Static Analysis Tools**: Utilize static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of integer overflow in the `malloc` call, you can implement a check before performing the multiplication:\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\n// Assuming bfloat16 is a defined type\ntypedef float bfloat16;\n\nvoid* safeMalloc(size_t m, size_t n) {\n    if (m > 0 && n > 0 && m <= std::numeric_limits<size_t>::max() / n) {\n        size_t totalSize = m * n * sizeof(bfloat16);\n        return malloc(totalSize);\n    } else {\n        std::cerr << \"Integer overflow detected or invalid size parameters.\" << std::endl;\n        return nullptr;\n    }\n}\n\nint main() {\n    size_t m = 1000;\n    size_t n = 1000;\n    bfloat16* array = static_cast<bfloat16*>(safeMalloc(m, n));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    // Use the allocated memory\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries to execute properly:\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access the maximum value for `size_t`.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-a82f7ba7-a914-4b41-86c5-7004292731fe",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper memory allocation using the `malloc` function. In the provided code snippet, the vulnerability is due to the incorrect use of `sizeof` with a type instead of an instance. Specifically, `malloc(sizeof(aocl_post_op_matrix_add))` should allocate memory based on the size of the type `aocl_post_op_matrix_add`, but if `aocl_post_op_matrix_add` is a pointer or an incomplete type, this can lead to incorrect memory allocation, potentially causing buffer overflows or memory corruption.\n\n### General Mitigation Advice\n\n1. **Correct Use of `sizeof`:** Ensure that `sizeof` is used with the correct type or instance to allocate the appropriate amount of memory.\n2. **Check for NULL:** Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives:** Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers for automatic memory management.\n4. **Initialize Allocated Memory:** Use functions like `calloc` or `memset` to initialize allocated memory to prevent undefined behavior from uninitialized memory access.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // For malloc and free\n#include <cstring> // For memset\n\n// Assuming aocl_post_op_matrix_add is a struct or class\nstruct aocl_post_op_matrix_add {\n    // Members of the struct\n};\n\nint main() {\n    // Correct use of sizeof with the type\n    aocl_post_op_matrix_add* ptr = (aocl_post_op_matrix_add*)malloc(sizeof(aocl_post_op_matrix_add));\n    \n    if (ptr == nullptr) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize allocated memory\n    memset(ptr, 0, sizeof(aocl_post_op_matrix_add));\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-83c94d83-991a-4a15-94f0-e613377003dd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the provided code snippet, `malloc( n_zp * sizeof( C_DSCALE_type )`, the vulnerability may occur if `n_zp` is not properly validated, leading to potential issues such as integer overflow, buffer overflow, or memory allocation failures. These issues can result in undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in memory allocation calculations are validated to prevent integer overflow or underflow.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` or `std::unique_ptr` for automatic memory management.\n4. **Limit Memory Usage**: Implement limits on memory allocation to prevent excessive memory usage that could lead to denial of service.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // for malloc and free\n\n// Assuming C_DSCALE_type is a defined type\ntypedef int C_DSCALE_type;\n\nvoid allocateMemory(size_t n_zp) {\n    // Validate n_zp to prevent integer overflow\n    if (n_zp == 0 || n_zp > SIZE_MAX / sizeof(C_DSCALE_type)) {\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return;\n    }\n\n    // Allocate memory\n    C_DSCALE_type* ptr = static_cast<C_DSCALE_type*>(malloc(n_zp * sizeof(C_DSCALE_type)));\n    \n    // Check if malloc succeeded\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(ptr);\n}\n\nint main() {\n    size_t n_zp = 10; // Example size\n    allocateMemory(n_zp);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-70ab156d-8469-4c5a-a17b-e987581fc8bf",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. This vulnerability can lead to various issues such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not properly managed. Specifically, the vulnerability sink `malloc(n_zp * sizeof(uint8_t))` can cause problems if `n_zp` is not properly validated, potentially leading to an integer overflow or allocation of insufficient memory.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the value of `n_zp` is validated before using it in the `malloc` function. It should be a positive integer and within a reasonable range to prevent integer overflow.\n\n2. **Check for NULL**: Always check the return value of `malloc`. If it returns `NULL`, it indicates that the memory allocation failed, and the program should handle this gracefully.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n\n4. **Free Allocated Memory**: Ensure that any memory allocated with `malloc` is properly freed using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    size_t n_zp = 10; // Example value, should be validated\n    if (n_zp == 0 || n_zp > SIZE_MAX / sizeof(uint8_t)) {\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    uint8_t* buffer = static_cast<uint8_t*>(malloc(n_zp * sizeof(uint8_t)));\n    if (buffer == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the buffer...\n\n    free(buffer);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-9b665f79-e5b4-4bb6-9c46-f8fec45550df",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. In the provided code snippet, `malloc( n_zp * sizeof( int8_t )`, the vulnerability may occur if `n_zp` is not properly validated. This can lead to integer overflow, resulting in insufficient memory allocation, buffer overflows, or memory corruption.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `n_zp` is validated to be a positive integer and within a reasonable range to prevent integer overflow.\n2. **Use Safer Alternatives**: Consider using `new` in C++ or `std::vector` for dynamic memory allocation, which provides automatic memory management and bounds checking.\n3. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Free Allocated Memory**: Ensure that any allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    size_t n_zp = 10; // Example value, ensure this is validated\n    if (n_zp > SIZE_MAX / sizeof(int8_t)) {\n        std::cerr << \"Size too large, potential overflow detected.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    int8_t* array = static_cast<int8_t*>(malloc(n_zp * sizeof(int8_t)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-523b0b76-10f0-459d-a345-54b2e91298de",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or improper handling of memory allocation failures. In the specific case of `malloc( n_zp * sizeof( int32_t )`, the vulnerability may occur if `n_zp` is not properly validated, leading to an incorrect or excessive amount of memory being allocated. This can result in undefined behavior, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in memory allocation calculations are validated to prevent excessive or negative values.\n2. **Check for Allocation Failure**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using safer memory allocation functions like `calloc`, which initializes the allocated memory to zero, or C++ alternatives like `new` which throw exceptions on failure.\n4. **Limit Memory Usage**: Implement limits on the amount of memory that can be allocated to prevent resource exhaustion.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cstdlib>\n\nint main() {\n    size_t n_zp = 10; // Example value, should be validated\n    if (n_zp > SIZE_MAX / sizeof(int32_t)) {\n        std::cerr << \"Requested size is too large.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    int32_t* array = static_cast<int32_t*>(malloc(n_zp * sizeof(int32_t)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    free(array);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdint>`: For fixed-width integer types.\n- `<cstdlib>`: For memory allocation functions and exit codes.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-3ec1425f-41ec-481f-a138-3d858fc64984",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, `malloc( n_zp * sizeof( float )`, the vulnerability may occur if `n_zp` is not properly validated, leading to an incorrect amount of memory being allocated. This can result in insufficient memory allocation or excessive memory allocation, both of which can be exploited by attackers.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in memory allocation are validated to prevent excessive or insufficient allocation.\n2. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using safer alternatives like `new` in C++ which automatically throws an exception on failure.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n_zp = 10; // Example size, should be validated\n    if (n_zp == 0 || n_zp > SIZE_MAX / sizeof(float)) {\n        std::cerr << \"Invalid size for memory allocation\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    float* array = static_cast<float*>(malloc(n_zp * sizeof(float)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    free(array); // Free the allocated memory\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f0feb7c1-e3a2-4dd2-b9f9-6b8c0aab57e9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc( n_zp * sizeof( bfloat16 )`, the vulnerability may occur if `n_zp` is not properly validated, leading to an incorrect or excessive memory allocation. This can result in security vulnerabilities such as arbitrary code execution or denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all inputs used in memory allocation are validated to prevent excessive or negative values.\n2. **Error Handling**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using safer memory allocation functions like `calloc`, which initializes the allocated memory to zero.\n4. **Limit Memory Usage**: Implement limits on memory allocation to prevent excessive memory usage.\n5. **Code Review and Testing**: Regularly review and test code to identify and fix potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\ntypedef struct {\n    // Define the structure of bfloat16 if necessary\n} bfloat16;\n\nint main() {\n    size_t n_zp = 10; // Example value, should be validated\n    if (n_zp > SIZE_MAX / sizeof(bfloat16)) {\n        std::cerr << \"Requested allocation size is too large.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    bfloat16* buffer = (bfloat16*)malloc(n_zp * sizeof(bfloat16));\n    if (buffer == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the buffer\n\n    free(buffer);\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-ef2f7bf2-c3cc-43e0-90c5-98c5ee81d107",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This can occur if the size calculation for `malloc` is incorrect, leading to insufficient memory allocation. In the provided example, the expression `malloc(n_scale * sizeof(DSCALE_type))` may be vulnerable if `n_scale` is not properly validated or if `DSCALE_type` is not correctly defined, leading to potential security risks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `n_scale` is validated to be within a safe range to prevent excessive memory allocation.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `calloc` for zero-initialized memory allocation or smart pointers in C++ for automatic memory management.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <iostream> // For std::cerr\n\ntypedef int DSCALE_type; // Example type definition\n\nvoid exampleFunction(size_t n_scale) {\n    // Validate n_scale to prevent excessive allocation\n    if (n_scale == 0 || n_scale > SIZE_MAX / sizeof(DSCALE_type)) {\n        std::cerr << \"Invalid scale size\" << std::endl;\n        return;\n    }\n\n    // Allocate memory safely\n    DSCALE_type* scaleArray = static_cast<DSCALE_type*>(malloc(n_scale * sizeof(DSCALE_type)));\n    if (scaleArray == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(scaleArray);\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-78d4a37b-4d1c-4e5e-92f3-354b8d2f0245",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided code snippet, `malloc(sizeof(aocl_post_op_sum))` is used, which can lead to incorrect memory allocation if `aocl_post_op_sum` is a type rather than an instance. This can result in undefined behavior, memory corruption, or application crashes.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct operand. If `aocl_post_op_sum` is a type, use `sizeof(type)`; if it's an instance, use `sizeof(instance)`.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for memory management, as they are type-safe and provide constructors and destructors.\n\n### Source Code Fix Recommendation\n\nIf `aocl_post_op_sum` is a type, the correct usage would be:\n\n```cpp\n#include <cstdlib> // Required for malloc\n\n// Assuming aocl_post_op_sum is a type\naocl_post_op_sum* ptr = (aocl_post_op_sum*)malloc(sizeof(aocl_post_op_sum));\nif (ptr == NULL) {\n    // Handle allocation failure\n}\n```\n\nAlternatively, using C++'s `new`:\n\n```cpp\n// Assuming aocl_post_op_sum is a type\naocl_post_op_sum* ptr = new aocl_post_op_sum();\nif (ptr == nullptr) {\n    // Handle allocation failure\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstdlib>`: This library is required for using `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-538c3dea-5810-4cb2-881f-60e8eb2315f3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc( sizeof( float )` is missing a closing parenthesis, which can cause a compilation error. Even if corrected, improper use of `malloc` can lead to memory leaks, buffer overflows, or undefined behavior if not handled properly.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Syntax**: Always ensure that the syntax is correct, including all necessary parentheses and semicolons.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used correctly to allocate the right amount of memory.\n4. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n5. **Consider Using `new` and `delete`**: In C++, prefer using `new` and `delete` for memory management, as they are type-safe and integrate better with C++ features.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    // Corrected malloc usage with error checking\n    float* ptr = (float*)malloc(sizeof(float));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14f;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-0af3a0f9-b431-4ce7-a035-b8327a578043",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc( sizeof( float )` is missing a closing parenthesis, which can cause a compilation error. Even if corrected, improper use of `malloc` can lead to memory leaks, buffer overflows, or undefined behavior if not handled properly.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Syntax**: Always ensure that the syntax is correct, including all necessary parentheses and semicolons.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used correctly to allocate the right amount of memory.\n4. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n5. **Consider Using `new` and `delete`**: In C++, prefer using `new` and `delete` for memory management, as they are type-safe and integrate better with C++ features.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    // Corrected malloc usage with error checking\n    float* ptr = (float*)malloc(sizeof(float));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14f;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-0b3aee85-d234-4c8d-8ae7-1e38b11c2a52",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, the vulnerability occurs when the size of the memory allocation is incorrectly calculated or insufficient for the intended use. In the example `malloc(sizeof(int32_t))`, the issue may arise if the allocated memory is intended to store more than one `int32_t` value, but only enough memory for a single `int32_t` is allocated. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Correct Memory Allocation**: Ensure that the size passed to `malloc` is sufficient for the intended use. If allocating memory for an array, multiply the size of the data type by the number of elements.\n2. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calculates the size.\n3. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Memory**: Use functions like `calloc` or explicitly initialize memory to avoid using uninitialized memory.\n5. **Free Memory**: Ensure that all allocated memory is properly freed to avoid memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <cstdint> // Required for int32_t\n\nint main() {\n    size_t num_elements = 10; // Example number of elements\n    int32_t* array = (int32_t*)malloc(num_elements * sizeof(int32_t));\n    \n    if (array == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize memory or use it as needed\n    for (size_t i = 0; i < num_elements; ++i) {\n        array[i] = 0; // Example initialization\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstdint>`: Required for `int32_t`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-53238f31-7d9c-445b-84ca-b2dd9ee695e0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, the vulnerability occurs when the size of the memory allocation is incorrectly calculated or insufficient for the intended use. In the example `malloc(sizeof(int32_t))`, the issue may arise if the allocated memory is intended to store more than one `int32_t` value, but only enough memory for a single `int32_t` is allocated. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Correct Memory Allocation**: Ensure that the size passed to `malloc` is sufficient for the intended use. If allocating memory for an array, multiply the size of the data type by the number of elements.\n2. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calculates the size.\n3. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Memory**: Use functions like `calloc` or explicitly initialize memory to avoid using uninitialized memory.\n5. **Free Memory**: Ensure that all allocated memory is properly freed to avoid memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <cstdint> // Required for int32_t\n\nint main() {\n    size_t num_elements = 10; // Example number of elements\n    int32_t* array = (int32_t*)malloc(num_elements * sizeof(int32_t));\n    \n    if (array == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize memory or use it as needed\n    for (size_t i = 0; i < num_elements; ++i) {\n        array[i] = 0; // Example initialization\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstdint>`: Required for `int32_t`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f57c017c-2ec2-4ced-a9c4-49d175df43c0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc( sizeof( float )` is missing a closing parenthesis, which can cause a compilation error. Even if corrected, improper use of `malloc` can lead to memory leaks, buffer overflows, or undefined behavior if not handled properly.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Syntax**: Always ensure that the syntax is correct, including all necessary parentheses and semicolons.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used correctly to allocate the right amount of memory.\n4. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n5. **Consider Using `new` and `delete`**: In C++, prefer using `new` and `delete` for memory management, as they are type-safe and integrate better with C++ features.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    // Corrected malloc usage with error checking\n    float* ptr = (float*)malloc(sizeof(float));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14f;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-cd392151-d34f-4e8c-84e2-d964fa317aa5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, the vulnerability occurs when the size of the memory allocation is incorrectly calculated or insufficient for the intended use. In the example `malloc(sizeof(int32_t))`, the issue may arise if the allocated memory is intended to store more than one `int32_t` value, but only enough memory for a single `int32_t` is allocated. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Correct Memory Allocation**: Ensure that the size passed to `malloc` is sufficient for the intended use. If allocating memory for an array, multiply the size of the data type by the number of elements.\n2. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calculates the size.\n3. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Memory**: Use functions like `calloc` or explicitly initialize memory to avoid using uninitialized memory.\n5. **Free Memory**: Ensure that all allocated memory is properly freed to avoid memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <cstdint> // Required for int32_t\n\nint main() {\n    size_t num_elements = 10; // Example number of elements\n    int32_t* array = (int32_t*)malloc(num_elements * sizeof(int32_t));\n    \n    if (array == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize memory or use it as needed\n    for (size_t i = 0; i < num_elements; ++i) {\n        array[i] = 0; // Example initialization\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstdint>`: Required for `int32_t`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-fde26ffd-a23e-45fa-973f-52e19bd6ef1c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc( sizeof( float )` is missing a closing parenthesis, which can cause a compilation error. Even if corrected, improper use of `malloc` can lead to memory leaks, buffer overflows, or undefined behavior if not handled properly.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Syntax**: Always ensure that the syntax is correct, including all necessary parentheses and semicolons.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used correctly to allocate the right amount of memory.\n4. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n5. **Consider Using `new` and `delete`**: In C++, prefer using `new` and `delete` for memory management, as they are type-safe and integrate better with C++ features.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    // Corrected malloc usage with error checking\n    float* ptr = (float*)malloc(sizeof(float));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14f;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-918e8253-0f9d-4ebe-b5b3-5cfba355c696",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, the vulnerability occurs when the size of the memory allocation is incorrectly calculated or insufficient for the intended use. In the example `malloc(sizeof(int32_t))`, the issue may arise if the allocated memory is intended to store more than one `int32_t` value, but only enough memory for a single `int32_t` is allocated. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Correct Memory Allocation**: Ensure that the size passed to `malloc` is sufficient for the intended use. If allocating memory for an array, multiply the size of the data type by the number of elements.\n2. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calculates the size.\n3. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Memory**: Use functions like `calloc` or explicitly initialize memory to avoid using uninitialized memory.\n5. **Free Memory**: Ensure that all allocated memory is properly freed to avoid memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <cstdint> // Required for int32_t\n\nint main() {\n    size_t num_elements = 10; // Example number of elements\n    int32_t* array = (int32_t*)malloc(num_elements * sizeof(int32_t));\n    \n    if (array == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize memory or use it as needed\n    for (size_t i = 0; i < num_elements; ++i) {\n        array[i] = 0; // Example initialization\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstdint>`: Required for `int32_t`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-bac5b6c8-eae5-4ab0-a4bf-970d8e7277c7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, the vulnerability is related to the allocation of memory using `malloc` without proper checks or considerations for the size and type of the elements being allocated.\n\n### General Mitigation Advice\n\n1. **Validate Input**: Ensure that the input values used in memory allocation are validated to prevent excessive or negative allocations.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use Safer Alternatives**: Consider using `new` in C++ or safer memory management libraries that provide automatic memory management.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use `sizeof` Correctly**: Ensure that `sizeof` is used correctly to calculate the size of the data type being allocated.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // for malloc and free\n\n// Assuming aocl_post_op_eltwise is a defined struct or class\nstruct aocl_post_op_eltwise {\n    // member variables\n};\n\nint main() {\n    size_t num_eltwise = 10; // Example value, should be validated\n    aocl_post_op_eltwise* eltwise_array = static_cast<aocl_post_op_eltwise*>(\n        malloc(num_eltwise * sizeof(aocl_post_op_eltwise))\n    );\n\n    if (eltwise_array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(eltwise_array);\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`/`EXIT_SUCCESS`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-5fa12e21-6a54-40ce-acff-3abe60d8cf25",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. Specifically, the vulnerability occurs when the `malloc` function is used without proper checks or calculations, which can result in insufficient memory allocation or incorrect memory usage.\n\nIn the provided code snippet, the expression `malloc(n * sizeof(BIAS_type))` is used to allocate memory. If `n` is not properly validated or if `sizeof(BIAS_type)` is incorrect, this can lead to memory allocation issues.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the value of `n` is validated to prevent integer overflow or underflow.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `calloc` for zero-initialized memory or smart pointers in C++ for automatic memory management.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cerr\n\ntypedef int BIAS_type; // Example type definition\n\nvoid allocateMemory(size_t n) {\n    // Validate input\n    if (n == 0 || n > SIZE_MAX / sizeof(BIAS_type)) {\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return;\n    }\n\n    // Allocate memory\n    BIAS_type* biasArray = static_cast<BIAS_type*>(malloc(n * sizeof(BIAS_type)));\n    \n    // Check if malloc succeeded\n    if (biasArray == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(biasArray);\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-230adf5d-2d56-433a-bde4-ac0594f89a8e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, `malloc( n * sizeof( int32_t )`, the vulnerability may occur if the value of `n` is not properly validated, leading to an incorrect or excessive amount of memory being allocated. This can result in security vulnerabilities such as buffer overflows or denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the value of `n` is validated before being used in the `malloc` function. This includes checking for negative values, excessively large values, or any other invalid input that could lead to improper memory allocation.\n\n2. **Use Safer Alternatives**: Consider using safer memory allocation functions such as `calloc`, which initializes the allocated memory to zero, or C++ alternatives like `new` or `std::vector` that provide automatic memory management.\n\n3. **Check for Allocation Failure**: Always check the return value of `malloc` to ensure that memory allocation was successful before using the allocated memory.\n\n4. **Free Allocated Memory**: Ensure that any memory allocated with `malloc` is properly freed using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size, should be validated\n    if (n > SIZE_MAX / sizeof(int32_t)) {\n        std::cerr << \"Requested size is too large.\" << std::endl;\n        return 1;\n    }\n\n    int32_t* array = static_cast<int32_t*>(malloc(n * sizeof(int32_t)));\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<int32_t>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstdlib>`: Required for `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-efd7d995-e999-4eaf-8a57-f96d5102323f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, `malloc( n * sizeof( int8_t )`, the vulnerability may occur if `n` is not properly validated, leading to incorrect memory allocation size calculations. This can result in insufficient memory being allocated, which can cause buffer overflows or other memory-related issues.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the value of `n` is validated to be a positive integer and within a reasonable range before using it in the `malloc` function.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `calloc` for zero-initialized memory allocation or C++ alternatives like `new` or `std::vector` for automatic memory management.\n4. **Free Allocated Memory**: Ensure that any allocated memory is properly freed when no longer needed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <cstdint>  // Required for int8_t\n#include <iostream> // Required for std::cerr\n\nint main() {\n    size_t n = 10; // Example size, should be validated\n    if (n <= 0) {\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return 1;\n    }\n\n    int8_t* ptr = static_cast<int8_t*>(malloc(n * sizeof(int8_t)));\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    free(ptr); // Free the allocated memory\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstdint>`: Required for `int8_t`.\n- `<iostream>`: Required for `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f79ea699-16b3-4ae0-aa2b-ee053502d72d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used improperly, leading to potential memory allocation issues. In the provided code snippet, `malloc( n * sizeof( float )`, there is a missing closing parenthesis, which can cause a compilation error. However, even if the syntax is corrected, improper use of `malloc` can lead to vulnerabilities such as buffer overflows, memory leaks, or undefined behavior if not handled correctly.\n\n### General Mitigation Advice\n\n1. **Proper Syntax**: Ensure that all parentheses are correctly placed and balanced.\n2. **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct data type.\n4. **Free Allocated Memory**: Always free the allocated memory using `free()` to prevent memory leaks.\n5. **Use Safer Alternatives**: Consider using C++ alternatives like `new` or containers like `std::vector` which handle memory management automatically.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float)); // Corrected malloc usage\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Example usage of the allocated array\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input/output operations.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [Common Weakness Enumeration (CWE-401: Missing Release of Memory after Effective Lifetime)](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-deb63dc0-6469-4bea-bcb1-f8a3522ce9d9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the provided code snippet, `malloc( n * sizeof( bfloat16 )`, the vulnerability may occur due to several reasons, such as:\n\n1. **Integer Overflow**: If `n` is a large value, multiplying it by `sizeof(bfloat16)` could result in an integer overflow, leading to insufficient memory allocation.\n2. **Unchecked Return Value**: If `malloc` fails, it returns `NULL`. If this return value is not checked, it can lead to dereferencing a null pointer, causing undefined behavior or a crash.\n3. **Improper Memory Management**: Failing to free the allocated memory can lead to memory leaks.\n\n### General Mitigation Advice\n\n- **Check for Integer Overflow**: Before calling `malloc`, ensure that the multiplication does not overflow.\n- **Check Return Value**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n- **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed when no longer needed.\n- **Use Safer Alternatives**: Consider using `calloc`, which initializes the allocated memory to zero, or higher-level abstractions like `std::vector` in C++.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\ntypedef float bfloat16; // Assuming bfloat16 is a float for this example\n\nbfloat16* allocateMemory(size_t n) {\n    // Check for potential overflow\n    if (n > std::numeric_limits<size_t>::max() / sizeof(bfloat16)) {\n        std::cerr << \"Size overflow detected!\" << std::endl;\n        return nullptr;\n    }\n\n    bfloat16* ptr = static_cast<bfloat16*>(malloc(n * sizeof(bfloat16)));\n    if (!ptr) {\n        std::cerr << \"Memory allocation failed!\" << std::endl;\n        return nullptr;\n    }\n\n    return ptr;\n}\n\nint main() {\n    size_t n = 100; // Example size\n    bfloat16* data = allocateMemory(n);\n    if (data) {\n        // Use the allocated memory\n        // ...\n\n        // Free the allocated memory\n        free(data);\n    }\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To use `std::numeric_limits`.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-807fa566-65b0-440f-b91a-f90423f6ebab",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(sizeof(aocl_post_op_bias))`, the vulnerability may occur if `aocl_post_op_bias` is a pointer or an incomplete type, leading to incorrect memory allocation size.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used on the correct type or object. If `aocl_post_op_bias` is a pointer, use `sizeof(*aocl_post_op_bias)` to allocate memory for the object it points to.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use Smart Pointers**: In C++, prefer using smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage dynamic memory automatically.\n4. **Initialize Memory**: Consider using `calloc` instead of `malloc` if you need the allocated memory to be initialized to zero.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for malloc, free\n#include <iostream> // for std::cerr\n\n// Assuming aocl_post_op_bias is a struct or class\nstruct aocl_post_op_bias {\n    // members of the struct\n};\n\nint main() {\n    // Correct usage of sizeof\n    aocl_post_op_bias* bias = (aocl_post_op_bias*)malloc(sizeof(aocl_post_op_bias));\n    \n    if (bias == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(bias);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for `std::cerr` to output error messages.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-d9a6615b-2fbc-4c4f-bff9-d67d7db36a73",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(sizeof(aocl_post_op))`, the vulnerability may occur if `aocl_post_op` is a type that requires more memory than what `sizeof` returns, or if `aocl_post_op` is not a type at all, leading to incorrect memory allocation.\n\n### General Mitigation Advice\n\n1. **Use `new` in C++**: Prefer using `new` for memory allocation in C++ as it automatically calls constructors and is type-safe.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used on the correct type or object.\n4. **Initialize Allocated Memory**: Consider using `calloc` instead of `malloc` if you need zero-initialized memory.\n5. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n\n// Assuming aocl_post_op is a type\nstruct aocl_post_op {\n    // Members of the struct\n};\n\nint main() {\n    // Correct usage of malloc with sizeof\n    aocl_post_op* ptr = (aocl_post_op*)malloc(sizeof(aocl_post_op));\n    if (ptr == nullptr) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1d0df909-050a-46e6-82eb-a9cbb23fb21d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, specifically when copying data into a buffer without ensuring that the destination buffer is large enough to hold the data being copied. This can lead to buffer overflow vulnerabilities, which may result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy(&float_temp_accum, &rounded, sizeof(float));\n```\n\nThis line of code copies the contents of `rounded` into `float_temp_accum` assuming both are of type `float`. If the types or sizes do not match, or if `float_temp_accum` is not properly allocated, this can lead to vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Buffer Sizes**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` which provide better type safety and can handle overlapping memory regions.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is correctly sized and consider using safer alternatives. Here is a revised version of the code using `std::copy`:\n\n```cpp\n#include <algorithm> // for std::copy\n#include <cstring>   // for std::memcpy\n\nfloat float_temp_accum;\nfloat rounded;\n\n// Using std::copy for better type safety\nstd::copy(reinterpret_cast<const char*>(&rounded),\n          reinterpret_cast<const char*>(&rounded) + sizeof(float),\n          reinterpret_cast<char*>(&float_temp_accum));\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<algorithm>`: Provides the `std::copy` function.\n- `<cstring>`: Provides the `std::memcpy` function, although it is not used in the fixed example.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0df1ef00-4b67-47b3-a8d0-f334ea64692a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the improper use of the `memcpy` function in C++. The function call `memcpy( &inter_temp, &float_temp_accum, sizeof( float )` is potentially unsafe because it assumes that the destination buffer `inter_temp` is large enough to hold the data being copied from `float_temp_accum`. If `inter_temp` is not properly sized, this can lead to buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities such as data corruption or code execution.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Buffer Sizes**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` if overlapping memory areas are involved.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly conduct code reviews to catch potential issues early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer is correctly sized and use safer functions if possible. Here's a corrected version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    float float_temp_accum = 123.456f;\n    float inter_temp; // Ensure this is the correct type and size\n\n    // Use memcpy safely\n    std::memcpy(&inter_temp, &float_temp_accum, sizeof(float));\n\n    std::cout << \"inter_temp: \" << inter_temp << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<iostream>`: For input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9e2c6d2b-d010-4cc5-bb5c-3ca7307e81ec",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The specific issue is with the line:\n\n```cpp\nmemcpy(temp_accum, &rounded, sizeof(float));\n```\n\nThis line of code attempts to copy the contents of a `float` variable `rounded` into a buffer `temp_accum`. The vulnerability occurs if `temp_accum` is not large enough to hold the data being copied, leading to a buffer overflow. Buffer overflows can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Ensure Buffer Size**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Functions**: Consider using safer alternatives like `std::copy` or `std::memmove` if applicable, which provide better type safety and can prevent some common mistakes.\n3. **Bounds Checking**: Implement bounds checking to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that `temp_accum` is properly sized. If `temp_accum` is intended to hold a single `float`, ensure it is declared as such:\n\n```cpp\nfloat temp_accum;\nmemcpy(&temp_accum, &rounded, sizeof(float));\n```\n\nAlternatively, if `temp_accum` is an array, ensure it is large enough:\n\n```cpp\nfloat temp_accum[1];\nmemcpy(temp_accum, &rounded, sizeof(float));\n```\n\n### Library Dependencies\n\nThe code example provided requires the following standard library:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cb00ea9f-6ba4-440f-9d16-d84c1e5a1c4e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability identified with the use of the `memcpy` function in C++ arises from improper handling of memory operations, which can lead to buffer overflows, data corruption, or undefined behavior. Specifically, the issue in the code snippet `memcpy( &inter_temp, temp_accum, sizeof( float )` is that it assumes `temp_accum` points to a valid memory location with at least `sizeof(float)` bytes available. If `temp_accum` does not meet this requirement, it can result in a buffer overflow, potentially leading to security vulnerabilities such as arbitrary code execution or application crashes.\n\n### General Mitigation Advice\n\n1. **Validate Input:** Ensure that the source buffer (`temp_accum`) is properly allocated and contains enough data to be copied.\n2. **Use Safer Functions:** Consider using safer alternatives like `std::copy` or `std::memmove` which provide better safety checks.\n3. **Bounds Checking:** Always perform bounds checking before copying memory to ensure that the destination buffer is large enough to hold the data being copied.\n4. **Static Analysis Tools:** Use static analysis tools to detect potential buffer overflows and other memory-related issues.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::copy\n\n// Assuming inter_temp is a float and temp_accum is a pointer to float\nfloat inter_temp;\nfloat* temp_accum;\n\n// Ensure temp_accum is not null and has enough data\nif (temp_accum != nullptr) {\n    // Use std::copy for safer memory operations\n    std::copy(temp_accum, temp_accum + 1, &inter_temp);\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy` if used.\n- `<algorithm>`: Required for `std::copy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-35618401-f4bd-4008-97d8-6cabd4d8a097",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size parameter passed to `malloc` is incorrect, unchecked, or derived from untrusted sources, which can result in insufficient memory allocation or excessive memory consumption.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input sizes before using them in memory allocation functions.\n2. **Use Safer Alternatives**: Consider using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Limit Memory Usage**: Implement limits on the amount of memory that can be allocated to prevent excessive memory consumption.\n5. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t size = 10; // Example size, should be validated\n    if (size <= 0 || size > MAX_ALLOWED_SIZE) { // Validate size\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return 1;\n    }\n\n    int* ptr = (int*)malloc(size * sizeof(int));\n    if (ptr == nullptr) { // Check if malloc succeeded\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < size; ++i) {\n        ptr[i] = i;\n    }\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-84440901-519b-4a06-8517-f6c3e1e953ff",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or improper memory access. Specifically, calling `malloc(4)` without proper checks and handling can lead to vulnerabilities if the allocated memory is not sufficient for the intended use or if the memory is not properly managed.\n\n### General Mitigation Advice\n\n1. **Validate Input:** Ensure that the size passed to `malloc` is appropriate for the data structure or object being allocated.\n2. **Check Return Value:** Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives:** Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage memory automatically.\n4. **Free Allocated Memory:** Ensure that any memory allocated with `malloc` is properly freed using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nBelow is a corrected version of the code that addresses the vulnerability:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    // Allocate memory for an integer\n    int* ptr = static_cast<int*>(malloc(sizeof(int)));\n    \n    // Check if malloc succeeded\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 42;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstdlib>`: Required for `malloc` and `free` functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-771f8bbd-fbaf-4677-9f4e-cba207b378fe",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-a8a40e32-2e57-456a-b229-56a25e34e382",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-9bfa679d-0736-4d17-a9fb-d3d80e9b5093",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used incorrectly, potentially leading to buffer overflows, data corruption, or undefined behavior. In the provided code snippet, the issue is with the use of `memcpy`:\n\n```cpp\nmemcpy(&float_val, &inter_temp, sizeof(float));\n```\n\nThe problem here is that the `sizeof(float)` is used as the size argument, which may not match the actual size of the data being copied if `inter_temp` is not a `float`. This can lead to copying more or less data than intended, causing memory corruption or other unexpected behavior.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Size**: Always ensure that the size argument in `memcpy` matches the actual size of the data types involved.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if applicable, which provide better type safety.\n3. **Boundary Checks**: Implement boundary checks to ensure that the source and destination buffers are large enough to hold the data being copied.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the size of the data being copied matches the actual size of the data types involved. If `inter_temp` is not a `float`, adjust the size accordingly. Here's a corrected version assuming `inter_temp` is a `float`:\n\n```cpp\n#include <cstring> // Required for memcpy\n\nfloat float_val;\nfloat inter_temp;\n\n// Corrected memcpy usage\nmemcpy(&float_val, &inter_temp, sizeof(float_val));\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e4a29e31-3de0-48e3-8703-d3633af78962",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the misuse of the `memcpy` function in C++. The function call `memcpy(float_val, &inter_temp, sizeof(int32_t))` is problematic because it copies the memory content of an `int32_t` type into a location intended for a `float` type. This can lead to undefined behavior, data corruption, or security vulnerabilities due to type mismatch and incorrect memory handling.\n\n### General Mitigation Advice\n\n1. **Type Safety**: Ensure that the source and destination types are compatible when using `memcpy`.\n2. **Bounds Checking**: Always verify that the destination buffer is large enough to hold the data being copied.\n3. **Use Safer Alternatives**: Consider using higher-level abstractions or safer functions that perform type checking, such as `std::copy` for C++.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the data types are compatible and that the destination buffer is correctly sized. If the intention is to copy an integer value into a float, consider using type conversion instead of `memcpy`.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for memcpy\n\nint main() {\n    int32_t inter_temp = 42; // Example integer value\n    float float_val; // Destination float variable\n\n    // Correctly convert the integer to a float\n    float_val = static_cast<float>(inter_temp);\n\n    // Output the result\n    std::cout << \"Converted value: \" << float_val << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required for using `memcpy`, although not used in the fixed example.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-704: Incorrect Type Conversion or Cast](https://cwe.mitre.org/data/definitions/704.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5a98d368-73d5-4eea-b279-c2a00d77ff79",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the misuse of the `memcpy` function in C++. The function call:\n\n```cpp\nmemcpy( ( bf16_val ), (char *)( float_value ) + 2, sizeof ( bfloat16 ) );\n```\n\nThis line of code attempts to copy a portion of a `float` value into a `bfloat16` variable. The issue here is that `memcpy` is being used to perform a potentially unsafe memory operation, which can lead to undefined behavior, data corruption, or security vulnerabilities if the source and destination buffers are not properly managed.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions or methods that perform bounds checking, such as `std::copy` or `std::memmove`.\n3. **Type Safety**: Ensure that the types being copied are compatible and that any necessary conversions are handled explicitly.\n4. **Avoid Pointer Arithmetic**: Minimize the use of pointer arithmetic, which can lead to errors and vulnerabilities.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, consider using a safer approach to copy the data. Here's a revised version of the code:\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <cstdint> // Required for uint16_t\n\nvoid safeCopyBfloat16(uint16_t* bf16_val, float* float_value) {\n    if (bf16_val != nullptr && float_value != nullptr) {\n        // Ensure that the destination buffer is large enough\n        std::memcpy(bf16_val, reinterpret_cast<char*>(float_value) + 2, sizeof(uint16_t));\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For `std::memcpy`.\n- `<cstdint>`: For fixed-width integer types like `uint16_t`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-78a9672f-b6ce-40ff-a3f1-ed7a1379125f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size of the memory allocation is miscalculated or unchecked, which can result in insufficient memory being allocated or excessive memory consumption.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use `calloc` for Zero Initialization**: Consider using `calloc` instead of `malloc` if zero-initialization of the allocated memory is desired.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that addresses the vulnerability:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    double* array = static_cast<double*>(malloc(n * sizeof(double)));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<double>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Links\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-bd55cbd0-b9b5-4028-9203-f3a25f4d492e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability often occurs when the size of the memory allocation is miscalculated or unchecked, leading to insufficient memory being allocated or excessive memory usage.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `malloc`:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-fb0c5dc1-76fe-4437-8572-4f8dc331b7a3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability often occurs when the size of the memory allocation is miscalculated or unchecked, leading to insufficient memory being allocated or excessive memory usage.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `malloc`:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-d6d2b820-230f-4855-a22e-47c22f4607e9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability often occurs when the size of the memory allocation is miscalculated or unchecked, leading to insufficient memory being allocated or excessive memory usage.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `malloc`:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f887eb6c-85a3-41d5-912e-7e66e93a6de6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability often occurs when the size of the memory allocation is miscalculated or unchecked, leading to insufficient memory being allocated or excessive memory usage.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `malloc`:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-cac2bde3-cefa-45c3-9be2-0bd16ffb1da6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size of the memory allocation is miscalculated or unchecked, which can result in insufficient memory being allocated or excessive memory consumption.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use `calloc` for Zero Initialization**: Consider using `calloc` instead of `malloc` if zero-initialization of the allocated memory is desired.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that addresses the vulnerability:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    double* array = static_cast<double*>(malloc(n * sizeof(double)));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<double>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Links\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-7bfeac62-5471-4b29-8fc3-00916313d17b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability often occurs when the size of the memory allocation is miscalculated or unchecked, leading to insufficient memory being allocated or excessive memory usage.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `malloc`:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-4ebcb4ab-6b63-49a8-b171-e7af543ed775",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability often occurs when the size of the memory allocation is miscalculated or unchecked, leading to insufficient memory being allocated or excessive memory usage.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `malloc`:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-40b77251-d7f9-4525-82aa-17c419d26abd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability often occurs when the size of the memory allocation is miscalculated or unchecked, leading to insufficient memory being allocated or excessive memory usage.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `malloc`:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    float* array = (float*)malloc(n * sizeof(float));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<float>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-19a8c7b9-e070-43be-a995-d7349b7386bb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size of the memory allocation is miscalculated or unchecked, which can result in insufficient memory being allocated or excessive memory consumption.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use `calloc` for Zero Initialization**: Consider using `calloc` instead of `malloc` if zero-initialization of the allocated memory is desired.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that addresses the vulnerability:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    double* array = static_cast<double*>(malloc(n * sizeof(double)));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<double>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Links\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-933b0a25-fa40-436a-b429-b9282adb54ef",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-53e2fbb5-633e-4f0d-8e50-f4e6ced48e1b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-e61a7dc5-7fdf-4d82-ad53-13b2eed1b13e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-8f597468-f526-4fe1-9028-a2b73f44a31b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-6d81d977-0f3c-4aad-b949-e98794141db6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-aeb87a0d-c99b-48af-9036-d70f52df131b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-972e8b43-5ce5-4fd2-ab56-f4c86e4e6915",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-f75af888-fa0c-4b3c-b62a-5b91bf9823cb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings with a specified maximum length to prevent buffer overflows. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can lead to undefined behavior when the destination string is used, potentially causing security vulnerabilities such as buffer overflows or data corruption.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your code.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n#define POST_OPS_STR_LEN 5\n\nvoid safeCopy() {\n    char post_ops_str[POST_OPS_STR_LEN];\n    strncpy(post_ops_str, \"none\", POST_OPS_STR_LEN - 1);\n    post_ops_str[POST_OPS_STR_LEN - 1] = '\\0'; // Ensure null-termination\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: This header is required for using `strncpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-10621ef1-b5e3-4504-8641-576f703670c6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly, potentially leading to buffer overflows or data truncation. In C++, `strncpy` is often used to copy strings, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can lead to undefined behavior when the destination buffer is used as a string.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or C++ standard library functions such as `std::string` and its member functions.\n2. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null terminator.\n4. **Input Validation**: Validate input lengths before performing string operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative. If you must use `strncpy`, ensure proper null-termination:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Original code\n// strncpy(post_ops_str, ops_tok, POST_OPS_STR_LEN - 1);\n\n// Fixed code\nstd::strncpy(post_ops_str, ops_tok, POST_OPS_STR_LEN - 1);\npost_ops_str[POST_OPS_STR_LEN - 1] = '\\0'; // Ensure null-termination\n```\n\nAlternatively, use `std::string`:\n\n```cpp\n#include <string> // Required for std::string\n\nstd::string post_ops_str = ops_tok.substr(0, POST_OPS_STR_LEN - 1);\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<string>`: Required for `std::string`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-145dfed3-c12f-4710-97fb-1710187b8ee1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. This function is often used to copy strings, but it can lead to vulnerabilities if not handled correctly. The primary issue with `strncpy` is that it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters to copy. This can lead to buffer overflows, data corruption, and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and fix potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nFor the specific vulnerability sink:\n\n```cpp\n// Original code\nstrncpy(eltwise_ops_type_str, ops_tok, ELTWISE_OPS_TYPE_STR_LEN - 1);\n\n// Recommended fix using strlcpy (if available)\nstrlcpy(eltwise_ops_type_str, ops_tok, ELTWISE_OPS_TYPE_STR_LEN);\n\n// If strlcpy is not available, ensure null-termination manually\nstrncpy(eltwise_ops_type_str, ops_tok, ELTWISE_OPS_TYPE_STR_LEN - 1);\neltwise_ops_type_str[ELTWISE_OPS_TYPE_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nThe code example provided does not require any additional library dependencies beyond the standard C++ libraries. However, if `strlcpy` is used, it may require additional libraries or custom implementation as it is not part of the standard C++ library.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-38e7772a-4e46-4c1b-a993-05ede00168aa",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-6da48cb4-0eb3-47c7-a94b-a1ac1db80241",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-85b7a1f8-1f6d-4997-8619-07f1b41f5965",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size of the memory allocation is miscalculated or unchecked, which can result in insufficient memory being allocated or excessive memory consumption.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use `calloc` for Zero Initialization**: Consider using `calloc` instead of `malloc` if zero-initialization of the allocated memory is desired.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that addresses the vulnerability:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    double* array = static_cast<double*>(malloc(n * sizeof(double)));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<double>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Links\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f600942e-50d6-4d2c-bcc0-4d9812b28543",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size of the memory allocation is miscalculated or unchecked, which can result in insufficient memory being allocated or excessive memory consumption.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management and reduce the risk of memory leaks.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Validate Input**: Ensure that the size passed to `malloc` is properly validated and does not lead to integer overflow.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use `calloc` for Zero Initialization**: Consider using `calloc` instead of `malloc` if zero-initialization of the allocated memory is desired.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code that addresses the vulnerability:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t n = 10; // Example size\n    double* array = static_cast<double*>(malloc(n * sizeof(double)));\n\n    if (array == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < n; ++i) {\n        array[i] = static_cast<double>(i);\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Links\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-84924752-598c-4fde-998a-2a923643462c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-2d40ef31-8266-4084-9430-3a2836377783",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-47d9a372-1342-4df3-85da-13ea9fadfc46",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-8ad6000a-5850-40c8-be19-cd25252c4114",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-6a2d450f-78e5-4edc-8aec-470b80124c07",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-76691458-a053-4609-acf4-7dc86a585390",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-eda996be-b3aa-4b6e-8f36-98c831f1fc8d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-3d781710-94d2-4b55-9283-98a441a11df5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-2305eace-4672-4b03-b9c0-3e200b74d3db",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-87b6fe96-c140-4ddb-9bc7-ae43d5c87756",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-c7718cc1-5e4a-4a1f-b795-c97385c0ba65",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-6c8d351d-5f94-4ab1-a158-dbb3b7bccfe0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-07ca0985-3970-48fc-91a8-e5740629b28c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-27a2bb95-682b-414e-a9dd-d9c41e698d2d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-619f4de4-3377-4e1e-8a4b-cf47c9b5fe58",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-c4739b40-5d73-4683-9880-c8c134857d03",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is used in subsequent operations that assume it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, manually null-terminate the destination buffer.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before performing copy operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure the destination buffer is null-terminated\nstrncpy(post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN - 1);\npost_ops_str_dest[POST_OPS_STR_LEN - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-1fa7a845-5f64-4e7c-a1ac-c212ef95faa6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings with a specified maximum length to prevent buffer overflows. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can lead to undefined behavior when the destination string is used, potentially causing security vulnerabilities such as buffer overflows or data corruption.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your code.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n#define POST_OPS_STR_LEN 5\n\nvoid safeCopy() {\n    char post_ops_str[POST_OPS_STR_LEN];\n    strncpy(post_ops_str, \"none\", POST_OPS_STR_LEN - 1);\n    post_ops_str[POST_OPS_STR_LEN - 1] = '\\0'; // Ensure null-termination\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: This header is required for using `strncpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-91665dea-de7d-4882-b1b4-65c24317b3fe",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/lpgemm/f32f32f32/lpgemm_pack_a_f32_amd512vnni.c"
                },
                "region": {
                  "startLine": 958,
                  "startColumn": 3,
                  "endLine": 962,
                  "endColumn": 45,
                  "charOffset": 47822,
                  "charLength": 147,
                  "snippet": {
                    "text": "memcpy\n\t\t\t(\n\t\t\t  pack_a_buf + ( ic * KC ) + ( kr_full_pieces_loop_limit * MR ),\n\t\t\t  temp_pack_a_buf,\n\t\t\t  kr_partial_pieces * MR * sizeof( float )",
                    "rendered": {
                      "text": "memcpy\n\t\t\t(\n\t\t\t  pack_a_buf + ( ic * KC ) + ( kr_full_pieces_loop_limit * MR ),\n\t\t\t  temp_pack_a_buf,\n\t\t\t  kr_partial_pieces * MR * sizeof( float )",
                      "markdown": "`memcpy\n\t\t\t(\n\t\t\t  pack_a_buf + ( ic * KC ) + ( kr_full_pieces_loop_limit * MR ),\n\t\t\t  temp_pack_a_buf,\n\t\t\t  kr_partial_pieces * MR * sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "kernels/zen4/lpgemm/f32f32f32/lpgemm_pack_a_f32_amd512vnni.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47822,
                        "charLength": 147
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n\t\t\t  pack_a_buf + ( ic * KC ) + ( kr_full_pieces_loop_limit * MR ), <size of \n\t\t\t  pack_a_buf + ( ic * KC ) + ( kr_full_pieces_loop_limit * MR )>, \n\t\t\t  temp_pack_a_buf, \n\t\t\t  kr_partial_pieces * MR * sizeof( float )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bf5d0354-00c1-451c-838f-ddc9cc10f75c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_8x24.c"
                },
                "region": {
                  "startLine": 725,
                  "startColumn": 19,
                  "endLine": 725,
                  "endColumn": 22,
                  "charOffset": 20543,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-41e5e262-b709-48ca-8cda-7cccb61de713",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_8x24.c"
                },
                "region": {
                  "startLine": 485,
                  "startColumn": 19,
                  "endLine": 485,
                  "endColumn": 22,
                  "charOffset": 13556,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-368e1d56-0b52-4bd1-9834-042b5435f7d0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 4289,
                  "startColumn": 10,
                  "endLine": 4289,
                  "endColumn": 13,
                  "charOffset": 134928,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-4d06f8a9-8fd1-474b-8f6b-3bea5ec6616e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 4288,
                  "startColumn": 30,
                  "endLine": 4288,
                  "endColumn": 33,
                  "charOffset": 134913,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-6508f4d7-1bd4-4b8f-b414-e51e0c8941da",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 4065,
                  "startColumn": 10,
                  "endLine": 4065,
                  "endColumn": 13,
                  "charOffset": 128643,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-55dbff06-9ee0-49cc-b131-f99022815c0b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 3835,
                  "startColumn": 10,
                  "endLine": 3835,
                  "endColumn": 13,
                  "charOffset": 122249,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-609492a8-e24e-43b1-aed2-49e518513384",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 3834,
                  "startColumn": 30,
                  "endLine": 3834,
                  "endColumn": 33,
                  "charOffset": 122234,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-7a266a4b-4609-4caa-850f-00053d664c2d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 3374,
                  "startColumn": 10,
                  "endLine": 3374,
                  "endColumn": 13,
                  "charOffset": 109663,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0b221e9a-fcd2-47e1-93d6-d8d9a609a411",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 3373,
                  "startColumn": 30,
                  "endLine": 3373,
                  "endColumn": 33,
                  "charOffset": 109648,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-ea3b11c1-6219-4a9f-bf09-810bd91cba2e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 3129,
                  "startColumn": 10,
                  "endLine": 3129,
                  "endColumn": 13,
                  "charOffset": 102766,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-36069aef-2c39-4007-9eb7-037b4db5fd6c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 2877,
                  "startColumn": 10,
                  "endLine": 2877,
                  "endColumn": 13,
                  "charOffset": 95685,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b962ca89-9cd8-4618-a909-a3822e95bff1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 2876,
                  "startColumn": 30,
                  "endLine": 2876,
                  "endColumn": 33,
                  "charOffset": 95670,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0dfc48a2-a531-47c3-8124-87889bed392d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 2273,
                  "startColumn": 10,
                  "endLine": 2273,
                  "endColumn": 13,
                  "charOffset": 78534,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-ffc20552-7777-441e-ad3b-881832fac24b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 2272,
                  "startColumn": 30,
                  "endLine": 2272,
                  "endColumn": 33,
                  "charOffset": 78519,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-7e415b74-ce73-47a3-9ea5-3e4d7aa0aa0a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 1869,
                  "startColumn": 10,
                  "endLine": 1869,
                  "endColumn": 13,
                  "charOffset": 66334,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-c7de9693-fddc-4f15-a240-1c5a0b00093e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 1868,
                  "startColumn": 30,
                  "endLine": 1868,
                  "endColumn": 33,
                  "charOffset": 66319,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-4d00887b-bbc4-454b-98e5-ad835a4740ff",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 1450,
                  "startColumn": 10,
                  "endLine": 1450,
                  "endColumn": 13,
                  "charOffset": 53606,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d74ae544-e561-485a-91b2-30871b96692e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen4/3/sup/bli_gemmsup_cv_zen4_z12x4m.c"
                },
                "region": {
                  "startLine": 1449,
                  "startColumn": 30,
                  "endLine": 1449,
                  "endColumn": 33,
                  "charOffset": 53591,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-db39c21b-4f48-47dd-ad25-8aada5142271",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_30x8_knc.c"
                },
                "region": {
                  "startLine": 413,
                  "startColumn": 19,
                  "endLine": 413,
                  "endColumn": 22,
                  "charOffset": 14432,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d08251ba-8c29-4abd-b6d2-40894385fa82",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_30x8_knc.c"
                },
                "region": {
                  "startLine": 287,
                  "startColumn": 20,
                  "endLine": 287,
                  "endColumn": 23,
                  "charOffset": 11064,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-7224e45f-c441-4d74-87ae-1a9df647d05a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_30x8_knc.c"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 19,
                  "endLine": 231,
                  "endColumn": 22,
                  "charOffset": 9969,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-43ec0f69-bd75-4f5f-b62e-879c35661ffc",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_dgemm_knl_asm_30x8_knc.c"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 19,
                  "endLine": 193,
                  "endColumn": 22,
                  "charOffset": 8281,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d9d1b97c-8f10-48d0-a205-7aee098e8609",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_sgemm_knl_asm_30x16_knc.c"
                },
                "region": {
                  "startLine": 422,
                  "startColumn": 19,
                  "endLine": 422,
                  "endColumn": 22,
                  "charOffset": 14885,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e299a7b8-8c55-4eb2-8f63-2d5ce97ff33d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_sgemm_knl_asm_30x16_knc.c"
                },
                "region": {
                  "startLine": 296,
                  "startColumn": 20,
                  "endLine": 296,
                  "endColumn": 23,
                  "charOffset": 11514,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-664def03-38b1-4ab8-9550-77530163a49a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_sgemm_knl_asm_30x16_knc.c"
                },
                "region": {
                  "startLine": 240,
                  "startColumn": 19,
                  "endLine": 240,
                  "endColumn": 22,
                  "charOffset": 10419,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d8fd412f-b07b-4fa8-8e6e-a833c3b1411e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/other/bli_sgemm_knl_asm_30x16_knc.c"
                },
                "region": {
                  "startLine": 202,
                  "startColumn": 19,
                  "endLine": 202,
                  "endColumn": 22,
                  "charOffset": 8729,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-8d8eb45d-4375-4edc-987e-15762d19b8dd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/bli_dgemm_knl_asm_24x8.c"
                },
                "region": {
                  "startLine": 668,
                  "startColumn": 19,
                  "endLine": 668,
                  "endColumn": 22,
                  "charOffset": 20012,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d51a8b95-4300-47da-afac-a99e3036622d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/bli_dgemm_knl_asm_24x8.c"
                },
                "region": {
                  "startLine": 221,
                  "startColumn": 19,
                  "endLine": 221,
                  "endColumn": 22,
                  "charOffset": 7865,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-fa1dd3a5-09bf-4b9a-b463-76a0523ba4cc",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/bli_sgemm_knl_asm_24x16.c"
                },
                "region": {
                  "startLine": 665,
                  "startColumn": 19,
                  "endLine": 665,
                  "endColumn": 22,
                  "charOffset": 19871,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-dc354abc-81b6-467a-95f2-79304f9600ca",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/knl/3/bli_sgemm_knl_asm_24x16.c"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 19,
                  "endLine": 218,
                  "endColumn": 22,
                  "charOffset": 7724,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-294dcc73-358b-4e43-9be0-d75eda2d532c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen/1/bli_copyv_zen_int.c"
                },
                "region": {
                  "startLine": 233,
                  "startColumn": 2,
                  "endLine": 233,
                  "endColumn": 22,
                  "charOffset": 7983,
                  "charLength": 20,
                  "snippet": {
                    "text": "memcpy(y, x, n << 3)",
                    "rendered": {
                      "text": "memcpy(y, x, n << 3)",
                      "markdown": "`memcpy(y, x, n << 3)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "kernels/zen/1/bli_copyv_zen_int.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7983,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "memcpy_s(y, <size of y>,  x,  n << 3)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7451acf4-ace9-4755-8483-a79af3056523",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "kernels/zen/1/bli_copyv_zen_int.c"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 8,
                  "endLine": 72,
                  "endColumn": 28,
                  "charOffset": 2366,
                  "charLength": 20,
                  "snippet": {
                    "text": "memcpy(y, x, n << 2)",
                    "rendered": {
                      "text": "memcpy(y, x, n << 2)",
                      "markdown": "`memcpy(y, x, n << 2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "kernels/zen/1/bli_copyv_zen_int.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2366,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "memcpy_s(y, <size of y>,  x,  n << 2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5efea088-93ad-439c-ae29-95fc71f56e6a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "addon/aocl_gemm/aocl_gemm_f32f32f32of32_utils.c"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 3,
                  "endLine": 167,
                  "endColumn": 67,
                  "charOffset": 5127,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(reorder_buf_addr, input_buf_addr, (k * sizeof(BLIS_FLOAT)",
                    "rendered": {
                      "text": "memcpy(reorder_buf_addr, input_buf_addr, (k * sizeof(BLIS_FLOAT)",
                      "markdown": "`memcpy(reorder_buf_addr, input_buf_addr, (k * sizeof(BLIS_FLOAT)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "addon/aocl_gemm/aocl_gemm_f32f32f32of32_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5127,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(reorder_buf_addr, <size of reorder_buf_addr>,  input_buf_addr,  (k * sizeof(BLIS_FLOAT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-14a0af90-a0de-4a61-b722-9ae3eeace5e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_cher2.c"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 13,
                  "endLine": 79,
                  "endColumn": 35,
                  "charOffset": 1947,
                  "charLength": 22,
                  "snippet": {
                    "text": "malloc(n*sizeof(float)",
                    "rendered": {
                      "text": "malloc(n*sizeof(float)",
                      "markdown": "`malloc(n*sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_cher2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1947,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a35c64fa-7f9a-4e0f-9332-1bf2ad57d9fa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_cher2.c"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 13,
                  "endLine": 78,
                  "endColumn": 35,
                  "charOffset": 1909,
                  "charLength": 22,
                  "snippet": {
                    "text": "malloc(n*sizeof(float)",
                    "rendered": {
                      "text": "malloc(n*sizeof(float)",
                      "markdown": "`malloc(n*sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_cher2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1909,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-25688913-0177-4170-87c6-351d12857145",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_zgbmv.c"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 16,
                  "endLine": 82,
                  "endColumn": 39,
                  "charOffset": 2237,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc(n*sizeof(double)",
                    "rendered": {
                      "text": "malloc(n*sizeof(double)",
                      "markdown": "`malloc(n*sizeof(double)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_zgbmv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2237,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2bb78121-0d6e-4df8-919d-8e5b91a8f584",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2470,
                  "startColumn": 57,
                  "endLine": 2470,
                  "endColumn": 94,
                  "charOffset": 86257,
                  "charLength": 37,
                  "snippet": {
                    "text": "malloc(n * num_groups * sizeof(float)",
                    "rendered": {
                      "text": "malloc(n * num_groups * sizeof(float)",
                      "markdown": "`malloc(n * num_groups * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 86257,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2097ab1e-cf28-4b1c-9869-9e21a0fcb06a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2463,
                  "startColumn": 57,
                  "endLine": 2463,
                  "endColumn": 94,
                  "charOffset": 85716,
                  "charLength": 37,
                  "snippet": {
                    "text": "malloc(m * num_groups * sizeof(float)",
                    "rendered": {
                      "text": "malloc(m * num_groups * sizeof(float)",
                      "markdown": "`malloc(m * num_groups * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85716,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ee4eaba2-b087-463c-a765-7ff1c3ad49b8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2456,
                  "startColumn": 57,
                  "endLine": 2456,
                  "endColumn": 97,
                  "charOffset": 85291,
                  "charLength": 40,
                  "snippet": {
                    "text": "malloc(n * num_groups * sizeof(bfloat16)",
                    "rendered": {
                      "text": "malloc(n * num_groups * sizeof(bfloat16)",
                      "markdown": "`malloc(n * num_groups * sizeof(bfloat16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85291,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1a866294-b91d-4153-b2ad-f75d60d7e024",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2452,
                  "startColumn": 57,
                  "endLine": 2452,
                  "endColumn": 97,
                  "charOffset": 84905,
                  "charLength": 40,
                  "snippet": {
                    "text": "malloc(m * num_groups * sizeof(bfloat16)",
                    "rendered": {
                      "text": "malloc(m * num_groups * sizeof(bfloat16)",
                      "markdown": "`malloc(m * num_groups * sizeof(bfloat16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 84905,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bdea8071-53b8-4304-9400-73b7fb81e16c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2448,
                  "startColumn": 39,
                  "endLine": 2448,
                  "endColumn": 68,
                  "charOffset": 84670,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_pre_op_sf)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_pre_op_sf)",
                      "markdown": "`malloc(sizeof(aocl_pre_op_sf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 84670,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ed660336-8417-41b5-8bfe-a9e54c17869a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2446,
                  "startColumn": 39,
                  "endLine": 2446,
                  "endColumn": 68,
                  "charOffset": 84522,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_pre_op_sf)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_pre_op_sf)",
                      "markdown": "`malloc(sizeof(aocl_pre_op_sf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 84522,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a267cf62-f8b4-43a1-bfdf-7c42b9270e91",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2419,
                  "startColumn": 32,
                  "endLine": 2419,
                  "endColumn": 65,
                  "charOffset": 83344,
                  "charLength": 33,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_group_post_op)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_group_post_op)",
                      "markdown": "`malloc(sizeof(aocl_group_post_op)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 83344,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0511eab2-31e7-4804-8f0e-6dad28beebc0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2406,
                  "startColumn": 61,
                  "endLine": 2406,
                  "endColumn": 119,
                  "charOffset": 82604,
                  "charLength": 58,
                  "snippet": {
                    "text": "malloc( num_groups * scale_factor_len * sizeof( bfloat16 )",
                    "rendered": {
                      "text": "malloc( num_groups * scale_factor_len * sizeof( bfloat16 )",
                      "markdown": "`malloc( num_groups * scale_factor_len * sizeof( bfloat16 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 82604,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2edf2fa3-7194-4b19-8190-04a62735dc8d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2399,
                  "startColumn": 61,
                  "endLine": 2399,
                  "endColumn": 116,
                  "charOffset": 82137,
                  "charLength": 55,
                  "snippet": {
                    "text": "malloc( num_groups * scale_factor_len * sizeof( float )",
                    "rendered": {
                      "text": "malloc( num_groups * scale_factor_len * sizeof( float )",
                      "markdown": "`malloc( num_groups * scale_factor_len * sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 82137,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cbccc972-1a11-4e25-b5c2-f18e2937c182",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2393,
                  "startColumn": 39,
                  "endLine": 2393,
                  "endColumn": 71,
                  "charOffset": 81756,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_pre_op_sf )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_pre_op_sf )",
                      "markdown": "`malloc( sizeof( aocl_pre_op_sf )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 81756,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-49ca4fec-59bb-4172-8eb7-b5483978a44e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2384,
                  "startColumn": 58,
                  "endLine": 2384,
                  "endColumn": 111,
                  "charOffset": 81256,
                  "charLength": 53,
                  "snippet": {
                    "text": "malloc( num_groups * zp_vec_length * sizeof( int8_t )",
                    "rendered": {
                      "text": "malloc( num_groups * zp_vec_length * sizeof( int8_t )",
                      "markdown": "`malloc( num_groups * zp_vec_length * sizeof( int8_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 81256,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-83c75db4-0aee-4082-8f76-36c71cc5402b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2382,
                  "startColumn": 42,
                  "endLine": 2382,
                  "endColumn": 74,
                  "charOffset": 81081,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_pre_op_zp )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_pre_op_zp )",
                      "markdown": "`malloc( sizeof( aocl_pre_op_zp )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 81081,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5cb15052-8f4a-4e56-bff3-aa5fff357e0d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2358,
                  "startColumn": 28,
                  "endLine": 2358,
                  "endColumn": 57,
                  "charOffset": 80333,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_pre_op )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_pre_op )",
                      "markdown": "`malloc( sizeof( aocl_pre_op )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80333,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8d599087-a002-4733-9e9c-d00748b5c676",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2338,
                  "startColumn": 49,
                  "endLine": 2338,
                  "endColumn": 88,
                  "charOffset": 79599,
                  "charLength": 39,
                  "snippet": {
                    "text": "malloc( n_scale * sizeof( DSCALE_type )",
                    "rendered": {
                      "text": "malloc( n_scale * sizeof( DSCALE_type )",
                      "markdown": "`malloc( n_scale * sizeof( DSCALE_type )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 79599,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3e14df86-dd2b-4732-8fa0-1392bff05004",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2318,
                  "startColumn": 55,
                  "endLine": 2318,
                  "endColumn": 84,
                  "charOffset": 78866,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(float)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(float)",
                      "markdown": "`malloc( m * n * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 78866,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c95ce3a5-ce72-4118-b0c9-ef23331ab844",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2308,
                  "startColumn": 55,
                  "endLine": 2308,
                  "endColumn": 92,
                  "charOffset": 78362,
                  "charLength": 37,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(C_DSCALE_type)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(C_DSCALE_type)",
                      "markdown": "`malloc( m * n * sizeof(C_DSCALE_type)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 78362,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cfbd2ed7-3739-4792-8d0b-7c2cc91e601f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2295,
                  "startColumn": 55,
                  "endLine": 2295,
                  "endColumn": 86,
                  "charOffset": 77793,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int32_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int32_t)",
                      "markdown": "`malloc( m * n * sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 77793,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e4557fba-6a3e-4883-abba-94f86f0609d8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2285,
                  "startColumn": 55,
                  "endLine": 2285,
                  "endColumn": 85,
                  "charOffset": 77303,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int8_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int8_t)",
                      "markdown": "`malloc( m * n * sizeof(int8_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 77303,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2586e97c-de5c-456e-b91d-ee6bbd30aca1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2268,
                  "startColumn": 51,
                  "endLine": 2268,
                  "endColumn": 81,
                  "charOffset": 76599,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int8_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int8_t)",
                      "markdown": "`malloc( m * n * sizeof(int8_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 76599,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-18c120f1-6718-476b-8c44-a1a351d279e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2258,
                  "startColumn": 51,
                  "endLine": 2258,
                  "endColumn": 82,
                  "charOffset": 76093,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int32_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int32_t)",
                      "markdown": "`malloc( m * n * sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 76093,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6597b630-2ec5-4375-9120-2d0ecfdff5bd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2248,
                  "startColumn": 51,
                  "endLine": 2248,
                  "endColumn": 80,
                  "charOffset": 75589,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(float)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(float)",
                      "markdown": "`malloc( m * n * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75589,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e0b91819-74fc-4a16-abbb-2eaddcf67e02",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2238,
                  "startColumn": 51,
                  "endLine": 2238,
                  "endColumn": 83,
                  "charOffset": 75081,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(bfloat16)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(bfloat16)",
                      "markdown": "`malloc( m * n * sizeof(bfloat16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75081,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2bf4d8eb-42e6-4efe-a8e6-42212f3727d5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2228,
                  "startColumn": 31,
                  "endLine": 2228,
                  "endColumn": 72,
                  "charOffset": 74674,
                  "charLength": 41,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_post_op_matrix_mul )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_post_op_matrix_mul )",
                      "markdown": "`malloc( sizeof( aocl_post_op_matrix_mul )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 74674,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c6c5e0af-2a93-4efd-bf7d-fadf0224184f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2210,
                  "startColumn": 49,
                  "endLine": 2210,
                  "endColumn": 88,
                  "charOffset": 73976,
                  "charLength": 39,
                  "snippet": {
                    "text": "malloc( n_scale * sizeof( DSCALE_type )",
                    "rendered": {
                      "text": "malloc( n_scale * sizeof( DSCALE_type )",
                      "markdown": "`malloc( n_scale * sizeof( DSCALE_type )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73976,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c3a566c3-4d47-4e6f-a87b-5f0e657e658b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2190,
                  "startColumn": 55,
                  "endLine": 2190,
                  "endColumn": 84,
                  "charOffset": 73243,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(float)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(float)",
                      "markdown": "`malloc( m * n * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73243,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9161757b-7990-4c55-b04a-d2cb38da4cd1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2180,
                  "startColumn": 55,
                  "endLine": 2180,
                  "endColumn": 92,
                  "charOffset": 72739,
                  "charLength": 37,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(C_DSCALE_type)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(C_DSCALE_type)",
                      "markdown": "`malloc( m * n * sizeof(C_DSCALE_type)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 72739,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cb4de3c7-56e6-4bd9-a104-ca1d2c0306b2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2167,
                  "startColumn": 55,
                  "endLine": 2167,
                  "endColumn": 86,
                  "charOffset": 72170,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int32_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int32_t)",
                      "markdown": "`malloc( m * n * sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 72170,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a0d27b20-71a9-4c0f-9f34-050497fd3ce7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2157,
                  "startColumn": 55,
                  "endLine": 2157,
                  "endColumn": 85,
                  "charOffset": 71680,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int8_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int8_t)",
                      "markdown": "`malloc( m * n * sizeof(int8_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 71680,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b08736ce-39b7-4027-acf1-445cfddd7774",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2140,
                  "startColumn": 51,
                  "endLine": 2140,
                  "endColumn": 81,
                  "charOffset": 70976,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int8_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int8_t)",
                      "markdown": "`malloc( m * n * sizeof(int8_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 70976,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7c5db56d-a9ff-474c-ba0c-705d1c55a869",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2130,
                  "startColumn": 51,
                  "endLine": 2130,
                  "endColumn": 82,
                  "charOffset": 70470,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(int32_t)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(int32_t)",
                      "markdown": "`malloc( m * n * sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 70470,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eb695389-a7f0-4f43-8d77-4e227291c393",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2120,
                  "startColumn": 51,
                  "endLine": 2120,
                  "endColumn": 80,
                  "charOffset": 69966,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(float)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(float)",
                      "markdown": "`malloc( m * n * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69966,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1ad61acf-6d7d-4318-91d1-f119f3c10ffd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2110,
                  "startColumn": 51,
                  "endLine": 2110,
                  "endColumn": 83,
                  "charOffset": 69458,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( m * n * sizeof(bfloat16)",
                    "rendered": {
                      "text": "malloc( m * n * sizeof(bfloat16)",
                      "markdown": "`malloc( m * n * sizeof(bfloat16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69458,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a82f7ba7-a914-4b41-86c5-7004292731fe",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2099,
                  "startColumn": 31,
                  "endLine": 2099,
                  "endColumn": 72,
                  "charOffset": 69048,
                  "charLength": 41,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_post_op_matrix_add )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_post_op_matrix_add )",
                      "markdown": "`malloc( sizeof( aocl_post_op_matrix_add )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69048,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-83c94d83-991a-4a15-94f0-e613377003dd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2083,
                  "startColumn": 44,
                  "endLine": 2083,
                  "endColumn": 82,
                  "charOffset": 68283,
                  "charLength": 38,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( C_DSCALE_type )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( C_DSCALE_type )",
                      "markdown": "`malloc( n_zp * sizeof( C_DSCALE_type )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 68283,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-70ab156d-8469-4c5a-a17b-e987581fc8bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2070,
                  "startColumn": 48,
                  "endLine": 2070,
                  "endColumn": 80,
                  "charOffset": 67770,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( uint8_t )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( uint8_t )",
                      "markdown": "`malloc( n_zp * sizeof( uint8_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67770,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9b665f79-e5b4-4bb6-9c46-f8fec45550df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2059,
                  "startColumn": 48,
                  "endLine": 2059,
                  "endColumn": 79,
                  "charOffset": 67226,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( int8_t )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( int8_t )",
                      "markdown": "`malloc( n_zp * sizeof( int8_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67226,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-523b0b76-10f0-459d-a345-54b2e91298de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2048,
                  "startColumn": 48,
                  "endLine": 2048,
                  "endColumn": 80,
                  "charOffset": 66681,
                  "charLength": 32,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( int32_t )",
                      "markdown": "`malloc( n_zp * sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 66681,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3ec1425f-41ec-481f-a138-3d858fc64984",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2037,
                  "startColumn": 48,
                  "endLine": 2037,
                  "endColumn": 78,
                  "charOffset": 66138,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( float )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( float )",
                      "markdown": "`malloc( n_zp * sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 66138,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f0feb7c1-e3a2-4dd2-b9f9-6b8c0aab57e9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2026,
                  "startColumn": 48,
                  "endLine": 2026,
                  "endColumn": 81,
                  "charOffset": 65591,
                  "charLength": 33,
                  "snippet": {
                    "text": "malloc( n_zp * sizeof( bfloat16 )",
                    "rendered": {
                      "text": "malloc( n_zp * sizeof( bfloat16 )",
                      "markdown": "`malloc( n_zp * sizeof( bfloat16 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 65591,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef2f7bf2-c3cc-43e0-90c5-98c5ee81d107",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 2010,
                  "startColumn": 42,
                  "endLine": 2010,
                  "endColumn": 81,
                  "charOffset": 64810,
                  "charLength": 39,
                  "snippet": {
                    "text": "malloc( n_scale * sizeof( DSCALE_type )",
                    "rendered": {
                      "text": "malloc( n_scale * sizeof( DSCALE_type )",
                      "markdown": "`malloc( n_scale * sizeof( DSCALE_type )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 64810,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-78d4a37b-4d1c-4e5e-92f3-354b8d2f0245",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1982,
                  "startColumn": 24,
                  "endLine": 1982,
                  "endColumn": 58,
                  "charOffset": 63951,
                  "charLength": 34,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_post_op_sum )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_post_op_sum )",
                      "markdown": "`malloc( sizeof( aocl_post_op_sum )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 63951,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-538c3dea-5810-4cb2-881f-60e8eb2315f3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1950,
                  "startColumn": 62,
                  "endLine": 1950,
                  "endColumn": 85,
                  "charOffset": 62370,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc( sizeof( float )",
                    "rendered": {
                      "text": "malloc( sizeof( float )",
                      "markdown": "`malloc( sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 62370,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0af3a0f9-b431-4ce7-a035-b8327a578043",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1945,
                  "startColumn": 63,
                  "endLine": 1945,
                  "endColumn": 86,
                  "charOffset": 62121,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc( sizeof( float )",
                    "rendered": {
                      "text": "malloc( sizeof( float )",
                      "markdown": "`malloc( sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 62121,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0b3aee85-d234-4c8d-8ae7-1e38b11c2a52",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1935,
                  "startColumn": 62,
                  "endLine": 1935,
                  "endColumn": 87,
                  "charOffset": 61613,
                  "charLength": 25,
                  "snippet": {
                    "text": "malloc( sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( sizeof( int32_t )",
                      "markdown": "`malloc( sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 61613,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-53238f31-7d9c-445b-84ca-b2dd9ee695e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1930,
                  "startColumn": 63,
                  "endLine": 1930,
                  "endColumn": 88,
                  "charOffset": 61362,
                  "charLength": 25,
                  "snippet": {
                    "text": "malloc( sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( sizeof( int32_t )",
                      "markdown": "`malloc( sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 61362,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f57c017c-2ec2-4ced-a9c4-49d175df43c0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1895,
                  "startColumn": 68,
                  "endLine": 1895,
                  "endColumn": 91,
                  "charOffset": 59490,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc( sizeof( float )",
                    "rendered": {
                      "text": "malloc( sizeof( float )",
                      "markdown": "`malloc( sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 59490,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cd392151-d34f-4e8c-84e2-d964fa317aa5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1886,
                  "startColumn": 68,
                  "endLine": 1886,
                  "endColumn": 93,
                  "charOffset": 59075,
                  "charLength": 25,
                  "snippet": {
                    "text": "malloc( sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( sizeof( int32_t )",
                      "markdown": "`malloc( sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 59075,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fde26ffd-a23e-45fa-973f-52e19bd6ef1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1866,
                  "startColumn": 68,
                  "endLine": 1866,
                  "endColumn": 91,
                  "charOffset": 57980,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc( sizeof( float )",
                    "rendered": {
                      "text": "malloc( sizeof( float )",
                      "markdown": "`malloc( sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 57980,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-918e8253-0f9d-4ebe-b5b3-5cfba355c696",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1857,
                  "startColumn": 68,
                  "endLine": 1857,
                  "endColumn": 93,
                  "charOffset": 57565,
                  "charLength": 25,
                  "snippet": {
                    "text": "malloc( sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( sizeof( int32_t )",
                      "markdown": "`malloc( sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 57565,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bac5b6c8-eae5-4ab0-a4bf-970d8e7277c7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1833,
                  "startColumn": 28,
                  "endLine": 1833,
                  "endColumn": 80,
                  "charOffset": 56385,
                  "charLength": 52,
                  "snippet": {
                    "text": "malloc( num_eltwise * sizeof( aocl_post_op_eltwise )",
                    "rendered": {
                      "text": "malloc( num_eltwise * sizeof( aocl_post_op_eltwise )",
                      "markdown": "`malloc( num_eltwise * sizeof( aocl_post_op_eltwise )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56385,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5fa12e21-6a54-40ce-acff-3abe60d8cf25",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1802,
                  "startColumn": 43,
                  "endLine": 1802,
                  "endColumn": 74,
                  "charOffset": 55476,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc( n * sizeof( BIAS_type )",
                    "rendered": {
                      "text": "malloc( n * sizeof( BIAS_type )",
                      "markdown": "`malloc( n * sizeof( BIAS_type )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55476,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-230adf5d-2d56-433a-bde4-ac0594f89a8e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1789,
                  "startColumn": 47,
                  "endLine": 1789,
                  "endColumn": 76,
                  "charOffset": 54915,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc( n * sizeof( int32_t )",
                    "rendered": {
                      "text": "malloc( n * sizeof( int32_t )",
                      "markdown": "`malloc( n * sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54915,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-efd7d995-e999-4eaf-8a57-f96d5102323f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1778,
                  "startColumn": 47,
                  "endLine": 1778,
                  "endColumn": 75,
                  "charOffset": 54324,
                  "charLength": 28,
                  "snippet": {
                    "text": "malloc( n * sizeof( int8_t )",
                    "rendered": {
                      "text": "malloc( n * sizeof( int8_t )",
                      "markdown": "`malloc( n * sizeof( int8_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54324,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f79ea699-16b3-4ae0-aa2b-ee053502d72d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1767,
                  "startColumn": 47,
                  "endLine": 1767,
                  "endColumn": 74,
                  "charOffset": 53737,
                  "charLength": 27,
                  "snippet": {
                    "text": "malloc( n * sizeof( float )",
                    "rendered": {
                      "text": "malloc( n * sizeof( float )",
                      "markdown": "`malloc( n * sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53737,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-deb63dc0-6469-4bea-bcb1-f8a3522ce9d9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1756,
                  "startColumn": 47,
                  "endLine": 1756,
                  "endColumn": 77,
                  "charOffset": 53144,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( n * sizeof( bfloat16 )",
                    "rendered": {
                      "text": "malloc( n * sizeof( bfloat16 )",
                      "markdown": "`malloc( n * sizeof( bfloat16 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53144,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-807fa566-65b0-440f-b91a-f90423f6ebab",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1744,
                  "startColumn": 29,
                  "endLine": 1744,
                  "endColumn": 64,
                  "charOffset": 52647,
                  "charLength": 35,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_post_op_bias )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_post_op_bias )",
                      "markdown": "`malloc( sizeof( aocl_post_op_bias )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52647,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d9a6615b-2fbc-4c4f-bff9-d67d7db36a73",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 1368,
                  "startColumn": 33,
                  "endLine": 1368,
                  "endColumn": 63,
                  "charOffset": 38598,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc( sizeof( aocl_post_op )",
                    "rendered": {
                      "text": "malloc( sizeof( aocl_post_op )",
                      "markdown": "`malloc( sizeof( aocl_post_op )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38598,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1d0df909-050a-46e6-82eb-a9cbb23fb21d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 655,
                  "startColumn": 4,
                  "endLine": 655,
                  "endColumn": 56,
                  "charOffset": 19052,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy( &float_temp_accum, &rounded, sizeof( float )",
                    "rendered": {
                      "text": "memcpy( &float_temp_accum, &rounded, sizeof( float )",
                      "markdown": "`memcpy( &float_temp_accum, &rounded, sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19052,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s( &float_temp_accum, <size of  &float_temp_accum>,  &rounded,  sizeof( float )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0df1ef00-4b67-47b3-a8d0-f334ea64692a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 648,
                  "startColumn": 4,
                  "endLine": 648,
                  "endColumn": 59,
                  "charOffset": 18787,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy( &inter_temp, &float_temp_accum, sizeof( float )",
                    "rendered": {
                      "text": "memcpy( &inter_temp, &float_temp_accum, sizeof( float )",
                      "markdown": "`memcpy( &inter_temp, &float_temp_accum, sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18787,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s( &inter_temp, <size of  &inter_temp>,  &float_temp_accum,  sizeof( float )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9e2c6d2b-d010-4cc5-bb5c-3ca7307e81ec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 623,
                  "startColumn": 4,
                  "endLine": 623,
                  "endColumn": 49,
                  "charOffset": 18240,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy( temp_accum, &rounded, sizeof( float )",
                    "rendered": {
                      "text": "memcpy( temp_accum, &rounded, sizeof( float )",
                      "markdown": "`memcpy( temp_accum, &rounded, sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18240,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s( temp_accum, <size of  temp_accum>,  &rounded,  sizeof( float )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cb00ea9f-6ba4-440f-9d16-d84c1e5a1c4e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 616,
                  "startColumn": 4,
                  "endLine": 616,
                  "endColumn": 52,
                  "charOffset": 17982,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy( &inter_temp, temp_accum, sizeof( float )",
                    "rendered": {
                      "text": "memcpy( &inter_temp, temp_accum, sizeof( float )",
                      "markdown": "`memcpy( &inter_temp, temp_accum, sizeof( float )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17982,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s( &inter_temp, <size of  &inter_temp>,  temp_accum,  sizeof( float )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-35618401-f4bd-4008-97d8-6cabd4d8a097",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 155,
                  "startColumn": 12,
                  "endLine": 155,
                  "endColumn": 24,
                  "charOffset": 4781,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4781,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-84440901-519b-4a06-8517-f6c3e1e953ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 149,
                  "startColumn": 12,
                  "endLine": 149,
                  "endColumn": 23,
                  "charOffset": 4697,
                  "charLength": 11,
                  "snippet": {
                    "text": "malloc( 4 )",
                    "rendered": {
                      "text": "malloc( 4 )",
                      "markdown": "`malloc( 4 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4697,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-771f8bbd-fbaf-4677-9f4e-cba207b378fe",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/include/bli_x86_asm_macros.h"
                },
                "region": {
                  "startLine": 250,
                  "startColumn": 12,
                  "endLine": 250,
                  "endColumn": 15,
                  "charOffset": 6885,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-a8a40e32-2e57-456a-b229-56a25e34e382",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/include/bli_x86_asm_macros.h"
                },
                "region": {
                  "startLine": 233,
                  "startColumn": 8,
                  "endLine": 233,
                  "endColumn": 11,
                  "charOffset": 6436,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-9bfa679d-0736-4d17-a9fb-d3d80e9b5093",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 4,
                  "endLine": 122,
                  "endColumn": 49,
                  "charOffset": 4027,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(&float_val, &inter_temp, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(&float_val, &inter_temp, sizeof(float)",
                      "markdown": "`memcpy(&float_val, &inter_temp, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4027,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&float_val, <size of &float_val>,  &inter_temp,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e4a29e31-3de0-48e3-8703-d3633af78962",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 4,
                  "endLine": 114,
                  "endColumn": 53,
                  "charOffset": 3770,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy( float_val, &inter_temp, sizeof( int32_t )",
                    "rendered": {
                      "text": "memcpy( float_val, &inter_temp, sizeof( int32_t )",
                      "markdown": "`memcpy( float_val, &inter_temp, sizeof( int32_t )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3770,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s( float_val, <size of  float_val>,  &inter_temp,  sizeof( int32_t )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5a98d368-73d5-4eea-b279-c2a00d77ff79",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 4,
                  "endLine": 106,
                  "endColumn": 74,
                  "charOffset": 3480,
                  "charLength": 70,
                  "snippet": {
                    "text": "memcpy( ( bf16_val ), (char *)( float_value ) + 2, sizeof ( bfloat16 )",
                    "rendered": {
                      "text": "memcpy( ( bf16_val ), (char *)( float_value ) + 2, sizeof ( bfloat16 )",
                      "markdown": "`memcpy( ( bf16_val ), (char *)( float_value ) + 2, sizeof ( bfloat16 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_helpers.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3480,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "memcpy_s( ( bf16_val ), <size of  ( bf16_val )>,  (char *)( float_value ) + 2,  sizeof ( bfloat16 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-78a9672f-b6ce-40ff-a3f1-ed7a1379125f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_zhpr.c"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 13,
                  "endLine": 74,
                  "endColumn": 36,
                  "charOffset": 1657,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc(n*sizeof(double)",
                    "rendered": {
                      "text": "malloc(n*sizeof(double)",
                      "markdown": "`malloc(n*sizeof(double)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_zhpr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1657,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bd55cbd0-b9b5-4028-9203-f3a25f4d492e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_chemv.c"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 13,
                  "endLine": 73,
                  "endColumn": 35,
                  "charOffset": 1800,
                  "charLength": 22,
                  "snippet": {
                    "text": "malloc(n*sizeof(float)",
                    "rendered": {
                      "text": "malloc(n*sizeof(float)",
                      "markdown": "`malloc(n*sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_chemv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1800,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fb0c5dc1-76fe-4437-8572-4f8dc331b7a3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_chpmv.c"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 13,
                  "endLine": 71,
                  "endColumn": 35,
                  "charOffset": 1748,
                  "charLength": 22,
                  "snippet": {
                    "text": "malloc(n*sizeof(float)",
                    "rendered": {
                      "text": "malloc(n*sizeof(float)",
                      "markdown": "`malloc(n*sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_chpmv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1748,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d6d2b820-230f-4855-a22e-47c22f4607e9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_chbmv.c"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 13,
                  "endLine": 73,
                  "endColumn": 35,
                  "charOffset": 1849,
                  "charLength": 22,
                  "snippet": {
                    "text": "malloc(n*sizeof(float)",
                    "rendered": {
                      "text": "malloc(n*sizeof(float)",
                      "markdown": "`malloc(n*sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_chbmv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1849,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f887eb6c-85a3-41d5-912e-7e66e93a6de6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_chpr.c"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 13,
                  "endLine": 74,
                  "endColumn": 35,
                  "charOffset": 1653,
                  "charLength": 22,
                  "snippet": {
                    "text": "malloc(n*sizeof(float)",
                    "rendered": {
                      "text": "malloc(n*sizeof(float)",
                      "markdown": "`malloc(n*sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_chpr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1653,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cac2bde3-cefa-45c3-9be2-0bd16ffb1da6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_zgerc.c"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 13,
                  "endLine": 46,
                  "endColumn": 36,
                  "charOffset": 1131,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc(n*sizeof(double)",
                    "rendered": {
                      "text": "malloc(n*sizeof(double)",
                      "markdown": "`malloc(n*sizeof(double)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_zgerc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1131,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7bfeac62-5471-4b29-8fc3-00916313d17b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_cgerc.c"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 13,
                  "endLine": 46,
                  "endColumn": 35,
                  "charOffset": 1128,
                  "charLength": 22,
                  "snippet": {
                    "text": "malloc(n*sizeof(float)",
                    "rendered": {
                      "text": "malloc(n*sizeof(float)",
                      "markdown": "`malloc(n*sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_cgerc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1128,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4ebcb4ab-6b63-49a8-b171-e7af543ed775",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_cgemv.c"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 16,
                  "endLine": 84,
                  "endColumn": 38,
                  "charOffset": 2345,
                  "charLength": 22,
                  "snippet": {
                    "text": "malloc(n*sizeof(float)",
                    "rendered": {
                      "text": "malloc(n*sizeof(float)",
                      "markdown": "`malloc(n*sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_cgemv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2345,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-40b77251-d7f9-4525-82aa-17c419d26abd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_cher.c"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 13,
                  "endLine": 75,
                  "endColumn": 35,
                  "charOffset": 1712,
                  "charLength": 22,
                  "snippet": {
                    "text": "malloc(n*sizeof(float)",
                    "rendered": {
                      "text": "malloc(n*sizeof(float)",
                      "markdown": "`malloc(n*sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_cher.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1712,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-19a8c7b9-e070-43be-a995-d7349b7386bb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_zhpmv.c"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 13,
                  "endLine": 71,
                  "endColumn": 36,
                  "charOffset": 1756,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc(n*sizeof(double)",
                    "rendered": {
                      "text": "malloc(n*sizeof(double)",
                      "markdown": "`malloc(n*sizeof(double)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_zhpmv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1756,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-933b0a25-fa40-436a-b429-b9282adb54ef",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 1042,
                  "startColumn": 16,
                  "endLine": 1042,
                  "endColumn": 76,
                  "charOffset": 35400,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35400,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35400,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-53e2fbb5-633e-4f0d-8e50-f4e6ced48e1b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 1028,
                  "startColumn": 16,
                  "endLine": 1028,
                  "endColumn": 76,
                  "charOffset": 34801,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34801,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34801,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e61a7dc5-7fdf-4d82-ad53-13b2eed1b13e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 1014,
                  "startColumn": 16,
                  "endLine": 1014,
                  "endColumn": 76,
                  "charOffset": 34195,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34195,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34195,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8f597468-f526-4fe1-9028-a2b73f44a31b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 1002,
                  "startColumn": 16,
                  "endLine": 1002,
                  "endColumn": 76,
                  "charOffset": 33673,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33673,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33673,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6d81d977-0f3c-4aad-b949-e98794141db6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 990,
                  "startColumn": 16,
                  "endLine": 990,
                  "endColumn": 76,
                  "charOffset": 33151,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33151,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33151,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-aeb87a0d-c99b-48af-9036-d70f52df131b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 978,
                  "startColumn": 16,
                  "endLine": 978,
                  "endColumn": 76,
                  "charOffset": 32628,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32628,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32628,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-972e8b43-5ce5-4fd2-ab56-f4c86e4e6915",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 966,
                  "startColumn": 16,
                  "endLine": 966,
                  "endColumn": 76,
                  "charOffset": 32104,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32104,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32104,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f75af888-fa0c-4b3c-b62a-5b91bf9823cb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 956,
                  "startColumn": 16,
                  "endLine": 956,
                  "endColumn": 69,
                  "charOffset": 31665,
                  "charLength": 53,
                  "snippet": {
                    "text": "strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )",
                    "rendered": {
                      "text": "strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )",
                      "markdown": "`strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31665,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str,  POST_OPS_STR_LEN - 1 ,  \"none\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31665,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str,  \"none\",  POST_OPS_STR_LEN - 1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-10621ef1-b5e3-4504-8641-576f703670c6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 952,
                  "startColumn": 16,
                  "endLine": 952,
                  "endColumn": 70,
                  "charOffset": 31548,
                  "charLength": 54,
                  "snippet": {
                    "text": "strncpy( post_ops_str, ops_tok, POST_OPS_STR_LEN - 1 )",
                    "rendered": {
                      "text": "strncpy( post_ops_str, ops_tok, POST_OPS_STR_LEN - 1 )",
                      "markdown": "`strncpy( post_ops_str, ops_tok, POST_OPS_STR_LEN - 1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31548,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str,  POST_OPS_STR_LEN - 1 ,  ops_tok)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31548,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str,  ops_tok,  POST_OPS_STR_LEN - 1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-145dfed3-c12f-4710-97fb-1710187b8ee1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 946,
                  "startColumn": 12,
                  "endLine": 946,
                  "endColumn": 82,
                  "charOffset": 31317,
                  "charLength": 70,
                  "snippet": {
                    "text": "strncpy( eltwise_ops_type_str, ops_tok, ELTWISE_OPS_TYPE_STR_LEN - 1 )",
                    "rendered": {
                      "text": "strncpy( eltwise_ops_type_str, ops_tok, ELTWISE_OPS_TYPE_STR_LEN - 1 )",
                      "markdown": "`strncpy( eltwise_ops_type_str, ops_tok, ELTWISE_OPS_TYPE_STR_LEN - 1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31317,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "strcpy_s( eltwise_ops_type_str,  ELTWISE_OPS_TYPE_STR_LEN - 1 ,  ops_tok)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31317,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "strlcpy( eltwise_ops_type_str,  ops_tok,  ELTWISE_OPS_TYPE_STR_LEN - 1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-38e7772a-4e46-4c1b-a993-05ede00168aa",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 35,
                  "endLine": 46,
                  "endColumn": 43,
                  "charOffset": 2016,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-6da48cb4-0eb3-47c7-a94b-a1ac1db80241",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm_eltwise_ops.c"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 35,
                  "endLine": 46,
                  "endColumn": 40,
                  "charOffset": 2016,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-85b7a1f8-1f6d-4997-8619-07f1b41f5965",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_zhpr2.c"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 13,
                  "endLine": 78,
                  "endColumn": 36,
                  "charOffset": 1866,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc(n*sizeof(double)",
                    "rendered": {
                      "text": "malloc(n*sizeof(double)",
                      "markdown": "`malloc(n*sizeof(double)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_zhpr2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1866,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f600942e-50d6-4d2c-bcc0-4d9812b28543",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "frame/compat/cblas/src/cblas_zhpr2.c"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 13,
                  "endLine": 77,
                  "endColumn": 36,
                  "charOffset": 1827,
                  "charLength": 23,
                  "snippet": {
                    "text": "malloc(n*sizeof(double)",
                    "rendered": {
                      "text": "malloc(n*sizeof(double)",
                      "markdown": "`malloc(n*sizeof(double)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "frame/compat/cblas/src/cblas_zhpr2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1827,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-84924752-598c-4fde-998a-2a923643462c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1334,
                  "startColumn": 16,
                  "endLine": 1334,
                  "endColumn": 76,
                  "charOffset": 52553,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52553,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52553,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2d40ef31-8266-4084-9430-3a2836377783",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1319,
                  "startColumn": 16,
                  "endLine": 1319,
                  "endColumn": 76,
                  "charOffset": 51895,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51895,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51895,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-47d9a372-1342-4df3-85da-13ea9fadfc46",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1304,
                  "startColumn": 16,
                  "endLine": 1304,
                  "endColumn": 76,
                  "charOffset": 51247,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51247,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51247,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8ad6000a-5850-40c8-be19-cd25252c4114",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1289,
                  "startColumn": 16,
                  "endLine": 1289,
                  "endColumn": 76,
                  "charOffset": 50598,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 50598,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 50598,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6a2d450f-78e5-4edc-8aec-470b80124c07",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1274,
                  "startColumn": 16,
                  "endLine": 1274,
                  "endColumn": 76,
                  "charOffset": 49942,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49942,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49942,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76691458-a053-4609-acf4-7dc86a585390",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1252,
                  "startColumn": 16,
                  "endLine": 1252,
                  "endColumn": 76,
                  "charOffset": 49059,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49059,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49059,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eda996be-b3aa-4b6e-8f36-98c831f1fc8d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1231,
                  "startColumn": 16,
                  "endLine": 1231,
                  "endColumn": 76,
                  "charOffset": 48236,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48236,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48236,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3d781710-94d2-4b55-9283-98a441a11df5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1219,
                  "startColumn": 16,
                  "endLine": 1219,
                  "endColumn": 76,
                  "charOffset": 47713,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47713,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47713,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2305eace-4672-4b03-b9c0-3e200b74d3db",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1206,
                  "startColumn": 16,
                  "endLine": 1206,
                  "endColumn": 76,
                  "charOffset": 47121,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47121,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47121,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-87b6fe96-c140-4ddb-9bc7-ae43d5c87756",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1192,
                  "startColumn": 16,
                  "endLine": 1192,
                  "endColumn": 76,
                  "charOffset": 46503,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46503,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46503,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c7718cc1-5e4a-4a1f-b795-c97385c0ba65",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1177,
                  "startColumn": 16,
                  "endLine": 1177,
                  "endColumn": 76,
                  "charOffset": 45843,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45843,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45843,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6c8d351d-5f94-4ab1-a158-dbb3b7bccfe0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1162,
                  "startColumn": 16,
                  "endLine": 1162,
                  "endColumn": 76,
                  "charOffset": 45185,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45185,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45185,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-07ca0985-3970-48fc-91a8-e5740629b28c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1138,
                  "startColumn": 16,
                  "endLine": 1138,
                  "endColumn": 76,
                  "charOffset": 44226,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44226,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44226,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-27a2bb95-682b-414e-a9dd-d9c41e698d2d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1120,
                  "startColumn": 16,
                  "endLine": 1120,
                  "endColumn": 76,
                  "charOffset": 43387,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43387,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43387,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-619f4de4-3377-4e1e-8a4b-cf47c9b5fe58",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1105,
                  "startColumn": 16,
                  "endLine": 1105,
                  "endColumn": 76,
                  "charOffset": 42731,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42731,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42731,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c4739b40-5d73-4683-9880-c8c134857d03",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1087,
                  "startColumn": 16,
                  "endLine": 1087,
                  "endColumn": 76,
                  "charOffset": 41889,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                    "rendered": {
                      "text": "strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )",
                      "markdown": "`strncpy( post_ops_str_dest, post_ops_str, POST_OPS_STR_LEN )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41889,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str_dest,  POST_OPS_STR_LEN ,  post_ops_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41889,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str_dest,  post_ops_str,  POST_OPS_STR_LEN )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1fa7a845-5f64-4e7c-a1ac-c212ef95faa6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                },
                "region": {
                  "startLine": 1077,
                  "startColumn": 16,
                  "endLine": 1077,
                  "endColumn": 69,
                  "charOffset": 41462,
                  "charLength": 53,
                  "snippet": {
                    "text": "strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )",
                    "rendered": {
                      "text": "strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )",
                      "markdown": "`strncpy( post_ops_str, \"none\", POST_OPS_STR_LEN - 1 )`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41462,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "strcpy_s( post_ops_str,  POST_OPS_STR_LEN - 1 ,  \"none\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "bench/bench_aocl_gemm/bench_lpgemm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41462,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "strlcpy( post_ops_str,  \"none\",  POST_OPS_STR_LEN - 1 )"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}